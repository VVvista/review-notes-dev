[[toc]]
## 1.图的定义
**图**：$$G=(V,E)$$ 
$V$:顶点(数据元素)的有穷非空集合;$E$:两个顶点组成的边的有穷集合

若$<v,w> E$表示从$v$到$w$的一条边或弧，其中$v$为弧尾，$w$为弧头；每条边都有方向的图称为**有向图**

若$(v,w) E$表示$v$与$w$的一条边或弧，则该条边时无向的；每条边都有无方向的图称为**无向图**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_示例图.png">
    <p>$name</p>
</div>

$n$个顶点的无向图的边或弧数为$0-{n(n-1)}\ 2$,而具有${n(n-1)}/ 2$条边的无向图，称为**无向完全图**，即任意两个点都有一条边相连

$n$个顶点的有向图的边或弧数为$0-n(n-1)$,而具有$n(n-1)$条边的有向图，称为**有向完全图**，即任意顶点都有一条指向其他顶点的出度边和，指向该顶点的入度边

有很少边或弧的图称为**稀疏图**，有较多边或弧的图称为**稠密图**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_完全图.png">
    <p>$name</p>
</div>

在无向图中，具有$(v_i,v_j)$关系，则称$v_i$和$v_j$互为邻接点；与该顶点相关联的边的数目称为**顶点的度**
 
在有向图中，具有$<v_i,v_j>$关系，则称$v_i$邻接到$v_j$，$v_j$邻接于$v_i$；以该顶点为终点的有向边的条数称为**入度**，以该顶点为始点的有向边的条数称为**出度**，顶点的度等于该顶点的入度和出度之和

**子图**：设有两个图，$G=(V,E)$、$G1=(V1,E1)$，若$V1 \subseteq V$,$E1 \subseteq E$,则称$G1$是$G$的子图

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_子图.png">
    <p>$name</p>
</div>

**网**：边/弧带权的图

**路径**是连续的边构成的顶点序列；除路径起点和终点可以相同外，其余顶点均不相同的路径称为**简单路径**；路径上的边或弧的数目/权值之和称为**路径长度**

第一个顶点和最后一个顶点相同的路径称为**回路**；除路径起点和终点相同外，其余顶点均不相同的路径称为**简单回路**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_路径.png">
    <p>$name</p>
</div>

若从顶点$v$到$u$有路径，则称$v$和$u$是联通的。

在无(有)向图$G=(V,E)$ 中，若对任何两个顶点$v、u$都存在从$v$到$u$的路径，则称$G$是连通图(强连通图)

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_连通图.png">
    <p>$name</p>
</div>

**极大(强)连通子图**：子图$G1$是$G$连通子图，将$G$的任何不在子图中的顶点加入，子图不再连通

**连通分量(强连通分量)**：无(有)向图$G$的极大连通子图称为$G$的连通分量

**极小连通子图**：该子图是$G$的连通子图，在该子图中删除任何一条边/弧，子图不再连通

**生成树**：包含无向图$G$所有顶点的极小连通子图

**生成森林**：对非连通图，由各个连通分量的生成树的集合

## 2.图的存储结构
因为图的任意两个顶点间都可能存在联系，所以不能使用顺序存储结构存储图，但可以借助二维数组来表示元素间的问题

### 2.1邻接矩阵
**邻接矩阵表示法**：建立一个顶点表(记录各个顶点信息)和一个邻接矩阵(表示各个顶点之间的关系)

#### 2.1.1无向图的邻接矩阵表示法
* 设图$A=(V,E)$有$n$个顶点，则顶点表$Vexs[n]$定义为：


\begin{array}{c|lcr}
i & 0 & 1 & 2 & ... & {n-1} \\
\hline
Vexs[i] & V_1 & V_2 & ... & V_n \\
\end{array}


*图的邻接矩阵是一个二维数组$A.arcs[n][n]$定义为：


A.arcs[i][i]=
\begin{cases}
1, &如果(i,j) \in E \\
0, &其他 \\
\end{cases}


**特点**：
1. 无向图的邻接矩阵是对称的
1. 顶点$i$的度=第$i$行(列)中1的个数
1. 完全图的邻接矩阵中，对角元素为0，其余为1

#### 2.1.2有向图的邻接矩阵表示法
有向图的邻接矩阵$A.arcs[n][n]$定义为：


A.arcs[i][i]=
\begin{cases}
1, &如果<i,j> \in E \\
0, &其他 \\
\end{cases}


<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_邻接矩阵.png">
    <p>$name</p>
</div>


**在有向图的邻接矩阵中**：
1. 第$i$行含义：以结点$i$为尾的弧(即出度边)
1. 第$i$列含义：以结点$i$为头的弧(即入度边)

**特点**：
1. 有向图的邻接矩阵可能不对称
1. 顶点的出度=第$i$行元素之和
1. 顶点的入度=第$i$列元素之和
1. 顶点的度=第$i$行元素之和+第$i$列元素之和

#### 2.1.3有权图的邻接矩阵表示法
网的邻接矩阵$A.arcs[n][n]$定义为：


A.arcs[i][i]=
\begin{cases}
E_{ij}, &<i,j> 或(i,j) \in E \\
\infty , &无边/弧 \\
\end{cases}


<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_网的邻接矩阵.png">
    <p>$name</p>
</div>

#### 2.1.4邻接矩阵总结
**算法思想**：
1. 输入总顶点数和总边数
1. 依次输入点的信息存储在顶点表中
1. 初始化邻接矩阵，初始化每个权限

**邻接矩阵的优点**：适合完全图
1. 直观、简单、好理解
1. 便于查找任意两个顶点是否存在变
1. 便于查找任意顶点的所有邻接点
1. 便于计算任意顶点的度

**邻接矩阵的缺点**：
1. 不便于增加和删除顶点
1. 浪费空间：稀疏图的存储浪费空间
1. 浪费时间：统计稀疏图共有多少边

### 2.2邻接表
**邻接表表示法(链式)基本思想**：
 1. 顶点：按编号顺序将顶点数据存储在一维数组中
 1. 关联同一顶点的边：用线性链表存储

链表的每个结点由3个域组成：邻接点域(adjvex)、链域(nexttarc)、数据域(info).
邻接点域(adjvex)指示与顶点$v_i$连接的点再图中的位置，即顶点在一维数组中的位置；
链域(nextarc)指示下一条边或弧的结点；
数据域(info)存储和边或弧相关的信息，如权重。

一维数组的由链域和数据域组成。
数据域(data)存储顶点$v_i$的相关信息；
链域(firstarc)指向与该顶点相关的链表中的第一个结点

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_邻接表.png">
    <p>$name</p>
</div>

**无向图的邻接表特点**：
1. 邻接表不唯一
1. 若无向图有$n$个顶点，$e$条边，则其邻接表需$n$个头结点和$2e$个表结点。适合存储稀释图

**有向图的邻接表特点**：
1. 顶点$V_i$的出度：第$i$个单链表中的结点个数
1. 顶点$V_i$的入度：整个单链表中邻接点域值是$i-1$的结点个数
1. 找出度容易，找入度难

**有向图的逆邻接表特点**：
1. 顶点$V_i$的入度：第$i$个单链表中的结点个数
1. 顶点$V_i$的出度：整个单链表中邻接点域值是$i-1$的结点个数
1. 找入度容易，找出度难

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_邻接表和逆邻接表.png">
    <p>$name</p>
</div>

#### 2.2.3邻接表总结
算法思想：
1. 输入总顶点数和总边数
1. 建立顶点表，依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为null
1. 创建邻接表，依次输入每条边衣服的两个顶点，确定两个顶点的序号i和j，建立边结点，将此边结点分别插入到$v_i$和$v_j$对应的两个边链表的头部

【插图-解析】

邻接表与邻接矩阵的关系：

邻接表特点：
1. 方便找任一顶点的所有邻接点
1. 节约稀疏图的空间。需要$n$个头指针和$2e$个结点
1. 方便计算任一顶点的度
1. 不方便检查任意一对顶点间是否存在边

邻接表与邻接矩阵：

联系： 邻接表中每个链表对应邻接矩阵的一行，链表中结点个数等于一行中非零元素的个数

区别： 1. 对于任一确定的无向图，邻接矩阵时唯一的，但邻接表不唯一

2. 邻接矩阵的空间复杂度为$O(n^2)$,邻接表的空间复杂度为$n+2e$

用途： 邻接矩阵多用于稠密图，邻接表多用于稀疏图

**十字链表**：

为了解决有向图的结点求度难，将邻接表和逆邻接表的特点结合起来，十字链表是有向图的另一种链式存储结构

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_十字链表.png">
    <p>$name</p>
</div>

弧结点：尾域(tailvex)和头域(headvex)分别指示弧头和弧尾的顶点在图中的位置，链域(hlink)指向弧头相同的下一条弧，链域(tlink)指向弧尾相同的下一条弧，info域存储弧的相关信息

头结点：data域存储顶点信息，firstin和firstout域分别指向该顶点为弧头或弧尾的第一个弧结点

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_有向图的十字链表.png">
    <p>$name</p>
</div>

**邻接多重表**：

为了解决无向图每条边都要存储两遍问题，邻接多重表是无向图的另一种链式存储结构

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_邻接多重表链表.png">
    <p>$name</p>
</div>

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_邻接多重表数据域.png">
    <p>$name</p>
</div>

弧结点：mark为标识域，标记该条边是否被搜索过，ivex和jvex为该边依附的两个顶点在图中的位置，ilink指向下一条依附于顶点ivex的边，jlink指向下一条依附于顶点jvex的边,info域存储弧的相关信息

顶点结点：data和firstedge。data存与顶点有关的信息，firstedge指向第一条依附于该顶点的边

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_无向图的邻接多重表.png">
    <p>$name</p>
</div>

## 3.图的遍历
从一直的连通图中的某个顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历。

遍历实质：找每个顶点的邻接点的过程

因为图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的结点。

因此设置辅助数组$visited[n]$用来标记每个被访问过的顶点，初始状态中$visited[i]=0$，顶点$i$被访问过后，$visited[i]=1$，从而避免被多次访问

### 3.1深度优先遍历
深度优先搜索DFS遍历类似于树的先根遍历

遍历过程：
假设初始状态图中所有顶点都没有被访问，则先从图中的某个顶点$v$出发，访问此顶点，然后依次从$v$的未被访问的邻接点出发深度优先遍历图，直至图中所有与$v$有路径相同的顶点均被访问；若此时图中尚有未被访问的顶点，则选一个未被访问的顶点作为起点，重复上述步骤，直至所有顶点都被访问。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_图的遍历.png">
    <p>$name</p>
</div>

上图最后得到的顶点访问序列为：$v_1\to v_2\to v_4\to v_8\to v_5\to v_3\to v_6\to v_7$

代码实现：

```
void DFS(AMGraph G, int v){ // 图G为邻接矩阵类型
    visited[v]=true; // 访问第v个顶点
    for(w=0;w<G.vexnum;w++){// 依次检查邻接矩阵v所在的行
        if(G.arcs[v][w]!=0&& !visited[w]){
            DFS(G,W);
            // w为v的邻接点，如果w未访问，则递归调用DFS
}}}
```

用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描到该顶点所在行，时间复杂度为$O(n^2)$

### 3.2广度优先遍历
广度优先搜索BFS遍历类似于树的层次遍历

从图的某一个结点出发，首先依次访问该节点的所有相邻的结点，再按这些结点被访问的先后次序依次访问与他们相邻所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_图的遍历.png">
    <p>$name</p>
</div>

上图最后得到的顶点访问序列为：$v_1\to v_2\to v_3\to v_4\to v_5\to v_6\to v_7\to v_8$

### 3.3邻接表的遍历算法
邻接表表示图，虽然有$2e$个表结点，但只需扫描$e$个结点即可完成遍历，加上访问$n$个头结点的时间，时间复杂度为$O(n+e)$

结论：稠密图适用于在邻接矩阵上进行深度遍历，稀疏图适用于邻接表上进行深度遍历

效率比较：
1. 空间复杂度相同，都是$O(n)$(借用了堆栈或队列)
1. 时间复杂度至于存储结构(邻接矩阵或邻接表)有关，而与搜索路径无关

## 4.最小生成树
### 4.1生成树
生成树：所有顶点均由边连接在一起，但不存在回路的图
【插图】

一个图可以有多棵不同的生成树。所有的生成树具有以下共同特点：
1. 生成树的顶点个数与图的顶点个数相同
1. 生成树是图的极小连通子图，去掉一条边则非联通
1. 一个有n个顶点的连通图的生成树有$n-1$条边
1. 在生成树中再加一条边必然形成回路
1. 生成树中任意两个顶点间的路径是唯一的

注意：
1. 有n个顶点$n-1$条边的图不一定是生成树

**无向图的生成树**
深度优先生成树：
广度优先生成树：
【插图】

### 4.2最小生成树
给定一个无向网络，在该网的所有生成树中，使得各边权值之和之和最小的那棵生成树称为该网的最小生成树，也称为最小代价最小代价生成树

最小生成树可能不唯一

### 4.3构造最小生成树
MST性质：设$N=(V,E)$是一个连通图，$U$是顶点集$V$的一个非空子集。若边$(u,v)$是一条具有最小权值额边，其中$u属于U$,$v属于V-U$，则必存在一棵包含边$(u,v)$的最小生成树。
【插图-演示】

在生成树的构造过程中，图中$n$个顶点分属于两个集合：
* 已落在生成树上的顶点集
* 尚未落在生成树上的顶点集

#### 4.3.1构造最小生成树-prim算法
算法思想：
1. 设$N=(V,E)$是一个连通网，$TE$是$N$上最小的生成树中的边的集合；
1. 初始一个$TE={}$集合，然后找到一个结点，然后$TE$、$U-TE$集合找到最小权重的边，继续前两步

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_prim算法.png">
    <p>$name</p>
</div>

#### 4.3.2构造最小生成树-Kruskal算法
算法思想：
1. 设$N=(V,E)$是一个连通网，令最小生成树初始状态为只有$n$个顶点而无边的连通图$T=(V,{})$，每个顶点自成一个连通分量
1. 在设$E$中选取代价最小的边，若该边依附的顶点落在$T$中不同的连通分量上（不能形成环），则将该边加入到$T$中，否则舍去该边，选取下一条代价最小的边
1. 以此类推，直至$T$中所有顶点都在同一个连通分量中为止

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_Kruskal算法.png">
    <p>$name</p>
</div>

#### 4.3.3构造最小生成树-算法比较
prim算法：选择点，时间复杂度：$O(n^2)$($n$为顶点数)，适用于稠密图

Kruskal算法：选择边，时间复杂度：$O(eloge)$($e$为边数)，适用于稀疏图

## 5.最短路径问题
在有向网中使A点到B点的多条路径中，寻找一条各边权值之和最小的路径，即为最短路径

### 5.1两点间最短路径-Dijkstra(迪杰斯特拉)算法
<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_Dijkstra.png">
    <p>$name</p>
</div>

步骤：
1. 找到权值最小的边结点
1. 对于该结点的邻居，检查是否有前往他们最短的路径，如果有记录其距离
1. 重复上述过程，直到图中的每个结点的最短路径都找到
1. 计算最终路径

求解过程：

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_Dijkstra邻接矩阵.png">
    <p>$name</p>
</div>

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_Dijkstra求解过程.png">
    <p>$name</p>
</div>

### 5.2每一对顶点之间的最短路径-Floyd(弗洛伊德)算法
<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_Floyd.png">
    <p>$name</p>
</div>

步骤：
1. 初始设置一个$n$阶方阵，令其对角线元素为0，若存在弧$<v_i,v_j>$，则对应元素为权值；否则为无穷
1. 逐步在原直接路径中增加中间顶点，如加入中间顶点后路径变短，则修改之；否则维持原值。
1. 所有顶点试探完毕，算法结束

求解过程：

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_Floyd求解过程.png">
    <p>$name</p>
</div>

## 6.关键路径
AOE网解决关键路径：

关键路径：路径最长的路径

路径长度：路径上各活动持续时间之和

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_AOE网.png">
    <p>$name</p>
</div>

关键路径的4个描述量：
1. $ve(v_j)$：表示事件$v_j$最早发生的时间
1. $vl(v_j)$：表示事件$v_j$最迟发生的时间
1. $e(i)$：表示活动$a_i$最早开始的时间
1. $l(i)$：表示活动$a_i$最迟开始的时间
1. $l(i)-e(i)$:表示完成活动$a_i$的时间余量

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/图_AOE网的关键路径.png">
    <p>$name</p>
</div>
