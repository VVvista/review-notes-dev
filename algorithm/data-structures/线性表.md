[[toc]]
## 线性表是什么
线性表是由 0 或多个具有相同类型的结点组成的有序集合。日常中常见的点名册、电话簿、职工工资单等都是线性表示例。

若用 $(a_1,a_2,a_3,...,a_n)$ ( $n$ 为自然数 ) 表示一个线性表。
- 当 $n=0$ 时，线性表中无结点，这样的线性表称为空表
- 当 $n\ge 1$ 时，$a_1$ 记为线性表的表头，$a_n$ 为线性表的表尾
- 当 $n\ge 2$ 时，$a_i$ 称为 $a_{i+1}$ 的前驱结点，$a_{i+1}$ 称为 $a_i$ 的后继结点
- 当 $n=1$ 时，线性表只有一个结点，该结点即是表头也是表尾
- $n(n\ge 0)$ 称为线性表的长度

#### 线性表特点
* 线性表中的元素可以是各种各样的，但同一个线性表中的元素必定具有相同的特性，即属同一数据对象。
* 数据元素之间具有一种线性的或“一对一”的逻辑关系。
  * 除了第一个元素没有前驱结点，最后一个元素没有后继结点，其他每个元素都有一个前驱结点和一个后继结点。

#### 线性表的基本操作 
* 线性表的初始化
* 判断线性表是否为空
* 求线性表的长度
* 在线性表中插入一个结点
  * 在线性表表头插入一个结点
  * 在线性表表尾插入一个结点
  * 在线性表中间指定位置插入一个结点
* 删除线性表指定位置的结点
* 查找特殊值在线性表中的位置
* 修改线性表指定位置的元素值

## 线性表的顺序实现

### 顺序存储
- 什么是顺序存储？

用一组**连续的存储地址**来存储线性表中的结点的存储方式称为顺序存储方式。

> **线性表长度**：线性表中数据元素的个数，随着插入和删除操作，长度会发生变化。  
**线性表的最大存储容量**：线性表初始化时申请的存储空间，即线性表最多能存储的数据元素个数，初始化结束后该值不再变化，不随线性表长度的改变而改变。

- 顺序存储结构需要的三个属性：
  - 存储空间的起始位置：线性表的存储位置就是存储空间的存储位置。
  - 线性表的最大存储容量：$MaxSize$。
  - 线性表的当前长度：$length$。

- 线性表数据元素与存储地址的关系： 

若线性表中每个元素占用 $l$ 个存储空间，以第一个元素所占的存储单元为起始存储位置，线性表中第 $i$ 个和第 $i+1$ 个元素的存储位置具有以下关系：
$$LOC(a_{i+1})=LOC(a_i)+l$$  
第 $1$ 个和第 $i$ 个元素的存储位置：
$$LOC(a_i)=LOC(a_1)+(i-1)l$$  
所以在线性表中，若两个元素在表中是**逻辑相邻**的，则他们的存储地址是**物理相邻**的。  
即只要给定表头元素 $a_1$ 的存储地址和存储元素所需的字节数，便可确定表中任一元素的存储地址，从而实现对结点的随机存取操作。即线性表的顺序存储结构是**随机存取**的存储结构。

线性表 $(a_1,a_2,a_3,...,a_n)$ 的存储结构如下图所示：
<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_顺序存储.png">
    <p> 线性表的顺序存储 </p>
</div>

### 顺序表
- 什么是顺序表？

按照顺序存储方式存储的线性表称为顺序表。

- 什么是有序顺序表？

若顺序表中的元素按其值有序，则称其为有序顺序表。

#### 顺序表的插入
设顺序表 $A$ 的长度为 $n$，将字段值为 $item$ 的元素插入到第 $i$ 个位置，插入步骤如下：
- 保证顺序表存储空间未满，并且插入位置合法
- 将第 $i$ 个位置元素及其之后的所有元素后移一个位置
- 插入成功后，线性表长度变为 $n+1$

#### 顺序表的删除
设顺序表 $A$ 的长度为 $n$，删除第 $i$ 个位置的元素，删除步骤如下：
- 保证删除位置合服性
- 将第 $i$ 个位置之后的所有元素前移一个位置
- 删除成功后，线性表长度变为 $n-1$

#### 顺序表总结
- 特点：存储地址连续，数据元素存储依次存放；数据元素类型相同，数据元素可随机存取
- 优点：存储空间的利用率高，存取速度快，适用于存取需求多的线性表
- 缺点：静态存储形式，数据元素的个数不能自由扩充 (受存储空间的限制)；在插入、删除某个元素时，需要移动大量元素

## 线性表的链式实现

### 链式存储
> 线性表的顺序存储使用一段连续的物理地址存储数据，可以随机存取任意元素，但是在进行插入和删除操作时需要移动大量的元素。因此本节介绍链式存储，元素的存储位置随意，可以是连续的也可以是不连续，即结点的逻辑关系与物理存储位置之间没有关联，从而在不移动结点的情况下进行插入、删除操作

- 什么是链式存储？

数据元素的存储地址随机获取，并通过指针表示数据之间逻辑关系的存储结构就是链式存储方式。

- 什么是结点？

**数据域**和**指针域**构成的数据元素的存储映像称为结点。

**数据域**存放该结点的数据域的值，**指针域**存放该结点的前继或后继结点的地址信息

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_链式存储.png">
    <p> 链式表的结点结构 </p>
</div>

- 什么是链表？

由 $n$ 个结点连接成的线性表称为**链表**。根据结点指针域的不同，链表主要分为单链表、循环链表和双向链表。  

- 什么是首元结点、尾结点、头结点、头指针？

  - 链表中存储第一个数据元素的结点称为**首元结点**。     
  - 链表中的最后一个结点称为**尾结点**。  
  - 在链表的首元结点之前附设的一个结点，该结点称为**头结点**。头结点的数据域可以为空，也可以存放线性表长度等附加信息，但头结点不能计入链表长度值。  
  - **头指针**是指向链表中第一个结点的指针。若链表有头结点，则是指向头结点的指针，若链表没有头结点，则是指向首元结点的指针。  

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_链式表.png">
    <p> 链式表 </p>
</div>

### 单链表

- 什么是单链表？

结点只有一个指针域的链表成为**单链表**。  
数据域 $data$ 存放该结点的数据域的值，指针域 $next$ 存放该结点的后继结点的地址信息。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_单链表.png">
    <p> 单链表 </p>
</div>

- 什么是空链表？

若表中只有头结点，则链表长度为 0，此时称其为**空链表**。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_单链表空表.png">
    <p> 空链表 </p>
</div>

- 单链表的指针之间关系：  
若 $p$ 为指向单链表第 $i$ 个结点的指针，则可以知道：
  - $p.next$ 指向第 $i+1$ 个结点
  - $p.data$ 为 $i$ 个结点的数据域
  - $p.next.data$ 为 $i+1$ 个结点的数据域
 
通过头指针进入单链表，根据每个结点的指针域可以循环遍历整个链表。

#### 单链表的插入  

将结点 $x$ 插入到单链表中的指定位置，若指针 $p$ 指向 $x$ 插入位置的前一个结点，插入步骤如下：
- 将 $x$ 结点的指针指向 $p$ 的后继结点： $x.next=p.next$
- 将 $p$ 的指针指向 $x$ 结点： $p.next=x$
  
<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/链表_单链表的插入.png">
</div>

#### 单链表的删除  

删除单链表中的 $x$ 结点，若指针 $p$ 指向 $x$ 结点的前一个结点，删除步骤如下：
- 将 $p$ 的指针指向 $x$ 的后继结点：$p.next=p.next.next$
- 释放结点 $x$ 

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/链表_单链表的删除.png">
</div>

### 循环链表
> 从单链表的一个结点出发，只能访问链接在它后面的结点，而无法访问其前驱结点，根据单链表尾结点的指针域为空的特点，将尾结点的指针域指向头结点，从而使链表任何结点可以访问任意结点。

- 什么是循环链表？

当单链表最后一个结点的指针域指向头结点时形成环状的链表称为**循环链表**。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_循环链表.png">
    <p> 循环链表 </p>
</div>

- 什么是空循环链表？

当循环链表只包含一个头指针指向的头结点，其指针域存放指向自身的指针，称为**空循环链表**

- 循环链表与单链表的异同 

  - 循环链表可以从任意位置访问任意结点；单链表只能访问任一结点之后的结点。
  - 链表遍历的终止条件：结点的指针是否指向头指针；单链表遍历的终止条件：结点的指针是否为空。
  - 循环链表可以获取前驱结点(遍历整个链表)；单链表无法获取前驱结点。
  - 循环链表的插入和删除与单链表类似。

### 双向链表
> 循环链表从一个结点出发，循环遍历整个链表，才能找到其前驱结点，时间花费长，所以引入双向链表解决该问题。

- 什么是双向链表？

结点由**数据域**( $data$ )、**左指针域**( $prior$ )、**右指针域**( $next$ )组成的链表称为**双向链表**。  
左指针域和右指针域分别存放结点左右相邻结点的地址信息。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_双向链表.png">
    <p> 双向链表存储结构 </p>
</div>

链表中的头结点的左指针和尾结点的右指针均为 $null$。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_双向循环链表.png">
    <p> 循环链表 </p>
</div>

- 什么是双向循环链表？

在双向链表的基础上，头结点的左指针指向链表的位结点，尾结点的右指针指向头结点，这样的链表称为**双向循环链表**。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/线性表_非空双向循环链表.png">
    <p> 双向循环链表 </p>
</div>

- 双向链表的指针之间关系  
若 $p$ 为指向第 $i$ 个结点的指针，则可以知道：
   - $p.next$ 指向第 $i+1$ 个结点
   - $p.prior$ 指向第 $i-1$ 个结点
   - $p.prior.next=p.next.prior=p$ 
   
通过头指针进入双向循环链表，每个结点可以便利的访问其前驱结点和后继结点。

#### 双向链表的插入 

将结点 $x$ 插入到双向循环链表的指定位置，若指针 $p$ 指向 $x$ 插入位置的后一个结点，插入步骤如下：
- $x$ 结点的左指针指向 $p$ 的前驱结点： $x.prior=p.prior$
- $x$ 结点的右指针指向 $p$ 所在结点： $x.next=p$
- $p$ 的前驱结点的右指针指向 $x$ 结点： $p.prior.next=x$
- $p$ 的左指针指向 $x$ 结点： $p.prior=x$

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/链表_循环链表插入.png">
</div>

#### 双向链表的删除 

删除双向循环链表的结点 $x$，若指针 $p$ 指向 $x$ 结点，删除步骤如下：
- $p$ 的后继结点的左指针指向 $p$ 的前驱结点： $p.next.prior=p.prior$
- $p$ 的前驱结点的右指针指向 $p$ 的后继结点： $p.prior.next=p.next$
- 指针 $p$ 的前驱结点的右指针指向 $x$ 结点： $p.prior.next=x$
- 指针 $p$ 的左指针指向 $x$ 结点： $p.prior=x$

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/链表_循环链表删除.png">
</div>

### 链式存储总结
* 链式存储的优点：   
  - 结点空间可以动态申请和释放  
  - 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素

* 链式存储结构的缺点：  
  - 存储密度小，每个结点的指针域需额外占用存储空间，当每个结点的数据域所占字节不多时，指针域所占存储空间的比重很大。

## 线性表的顺序和链式实现比较

- 空间性能:
  - 顺序存储需要预分配存储空间，分配空间过大会造成空间的浪费；分配空间过小会造成数据溢出，元素个数受限。
  - 链式存储不需要分配存储空间，只要有存储空间就可以在链表中添加元素，元素个数不受限制。

- 时间性能:
  - 查找：顺序存储可随机查找，时间复杂度 $O(1)$，链式存储只能根据指针顺序查找，时间复杂度为 $O(n)$。
  - 插入和删除:
    - 顺序存储结构需要移动表大量的元素，时间复杂度为 $O(n)$。
    - 链式存储在确定操作结点后，插入和删除时间复杂度为 $O(1)$。
    
- 存储分配方式：
  - 顺序存储结构用一段连续的存储单元依次存储线性表的数据单元。
  - 链式存储结构用一组任意的存储单元存放线性表的元素。
  
- 存储密度：
  - 顺序存储结构不用为表示结点间的逻辑关系而增加额外的存储开销，存储密度等于1。
  - 单链表需要借助指针来体现元素间的逻辑关系，存储密度小于1。
