[[toc]]
## 算法

- 什么是算法？

算法是解决特定问题求解步骤的描述，在计算机中表现为指定的有限序列，并且每条指令表示一个或多个操作。

## 时间复杂度

- 度量算法执行时间的两种方法
  - 事后统计的方法：编写算法程序后再进行分析
    - 需要实际运行程序才能对算法的性能进行评测；
    - 算法的运算性能依赖于计算机的硬件、软件等环境因素，只有在同一机器的相同状态下，才能比较算法的优劣。 
  - 事前估算的方法：通过分析算法的时间复杂度来判断算法的优劣。
  
### 时间频度
- 什么是时间频度？   
一个算法中的语句执行次数称为**语句频度**或**时间频度**，记为 $T(n)$。
  - 算法花费的时间与算法中语句的执行次数成正比例；
  - 算法中语句执行次数多，它花费时间越长。

例如计算1-100的和：
```
// 方式1：使用for循环
int total=0;
int end=100;
for(int i=1:i<=end;i++){
    total += i;
}

// 方式2：公式直接计算
int total=0;
int end=100;
total = (1+end) * end/2;
}
```

#### 时间频度比较之忽略常数项
- $T(n)=2n+20$ 与 $T_1(n)=2n$ 随着 $n$ 增大，两个函数的曲线无限接近，所以 $T(n) 的常数项可忽略。

#### 时间频度比较之忽略低次项
- $T(n)=2n^2+3n+10$ 和 $T_1(n)=2n^2$ 随着 $n$ 增大两个函数的曲线无限接近，所以 $T(n) 的低次项 $3n+10$ 可忽略。

#### 时间频度比较之忽略低次项
- $T(n)=5n^2+7n$ 和 $T_1(n)=3n^2 + 2n$ 随着 $n$ 增大两个函数的曲线无限接近，所以 $T(n) 与 $T_1(n) 的系数可忽略。


### 时间复杂度
- 什么是时间复杂度？ 
通常算法中的基本操作语句的重复执行次数是关于 $n$ 的函数，用 $T(n)$ 表示；
  - 若有某个辅助函数 $f(n)$；
  - 使得当 $n$ 趋近于无穷大时，$T(n)/f(n)$ 的极限值为不等于零的常数，则称 $f(n)$ 是 $T(n)$ 的同数量级函数。
记作 $T(n) = O(f(n))$，称 $O(f(n))$ 为算法的渐进时间复杂度，简称**时间复杂度**。

- 时间复杂度的特点
  - 不同的 $T(n)$，时间复杂度可能相同。
    - 如：$T(n)=n^2+7n+6$ 与 $T(n)=3n^2+2n+2$ 的 $T(n)$ 不同，但时间复杂度相同，都为 $O(n^2)$。
    
- 计算时间复杂度的方法
  - 用常数 1 代替运行时间中的所有加法常数：$T(n)=n^2+7n+6 => T(n)=n^2+7n+1$
  - 修改后的运行次数函数中，只保留最高阶项：$T(n)=n^2+7n+1 => T(n)=n^2$
  - 去除最高阶项的系数：$T(n)=n^2 => T(n)=n^2 => O(n^2)$

- 常见的时间复杂度
  - 常数阶 $O(1)$
  - 对数阶 $O(log2n)$
  - 线性阶 $O(n)$
  - 线性对数阶 $O(nlog2n)$
  - 平方阶 $O(n^2)$
  - 立方阶 $O(n^3)$
  - k 次方阶 $O(n^k)$
  - 指数阶 $O(2^n)$  
  
常见的算法时间复杂度由小到大依次为：$Ο(1)<Ο(log2n)<Ο(n)<Ο(nlog2n)<Ο(n^2)<Ο(n^3)<Ο(n^k)<Ο(2^n)$，随着问题规模 $n$ 的不断增大，时间复杂度不断增大，算法的执行效率越低。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/常见的时间复杂度函数对比.png">
</div>

#### 常数阶 O(1)
无论代码执行多少行，只要没有结构等复杂结构，则该段代码的时间复杂度就是 $O(1)$。
```
int i=1;
int j=2;
++1;
j++;
int m=i+j;
```
解释说明：上述代码在执行的时候，消耗的时间并不随魔偶个变量的增长而增长，则无论该类代码有多少行，都可以用 $O(1)$ 表示其时间复杂度。

#### 线性阶 O(n)
```
for(i=1;i<=n;++i){
  j=i;
  j++;
}
```
解释说明：for 循环中的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此该类代码的时间复杂度用 $O(n)$ 标识。

#### 对数阶 O(log{2n})
无论代码执行多少行，只要没有结构等复杂结构，则该段代码的时间复杂度就是 $O(1)$。
```
int i=1;
while(i<n){
  i=i*2;
}
```
解释说明：在 while 循环中，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近。假设循环 x 次之后，i 就大于 2 了，此时循环退出，即 2 的 x 次方等于 n，
则 $x=log2n$。因此该代码的复杂度为 $O(log{2n})$。$O(log{2n})$ 中的底数 2 是根据代码变化的，若`i=i*3`，则是 $O(log{3n})$。

#### 对数阶 O(nlogN)
```
for(i=1;i<=n;++i){
  i=1;
  while(i<n){
  i=i*2;
} }
```
解释说明：将时间复杂度为 $O(logN)$的代码循环 N 遍，其时间复杂度即变为 $n*O(logN)$，即 $O(nlogN)$。

#### 平方阶 O(n^2)
```
for(i=1;i<=n;i++){
  for(j=1;j<=n;j++){
  a=i+j;
} }
```
解释说明：将时间复杂度为 $O(n)$ 的代码再嵌套循环一遍，时间复杂度则变为 $O(n^2)$。 

### 平均时间复杂度和最坏时间复杂度
- 什么是平均时间复杂度和最坏时间复杂度？
  - 所有可能的输入实例均以等概率出现的情况下，该算法的运行时间，称为**平均时间复杂度**。
  - 最坏情况下的时间复杂度称**最坏时间复杂度**。
  - 一般讨论的时间复杂度均是最坏情况下的时间复杂度。
    - 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上限，保证了算法的运行时间不会比最坏情况更长。
  - 平均时间复杂度和最坏时间复杂度是否一致与具体的算法有关。

## 空间复杂度
- 什么是空间复杂度？
算法所耗费的存储空间称为**空间复杂度**。

- 算法所占用的空间有哪些？
  - 算法本身占用的空间，输入、输出、指令、常数、变量等
  - 算法要使用的辅助空间
  
- 空间复杂度特点
  - 是对一个算法在运行过程中临时占用存储空间大小的量度。
  - 空间复杂度是关于 $n$ 的函数，随着 $n$ 的增大，占用的存储越大
    - 有的算法需要占用的 临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n


  
  
  