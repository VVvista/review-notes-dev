[[toc]]
## 时间复杂度

- 度量算法执行时间的两种方法
  - 事后统计的方法：编写算法程序后再进行分析
    - 需要实际运行程序才能对算法的性能进行评测；
    - 算法的运算性能依赖于计算机的硬件、软件等环境因素，只有在同一机器的相同状态下，才能比较算法的优劣。 
  - 事前估算的方法：通过分析算法的时间复杂度来判断算法的优劣。
  
### 时间频度
- 什么是时间频度？   
一个算法中的语句执行次数称为**语句频度**或**时间频度**，记为 $T(n)$。
  - 算法花费的时间与算法中语句的执行次数成正比例；
  - 算法中语句执行次数多，它花费时间越长。

例如计算1-100的和：
```
// 方式1：使用for循环
int total=0;
int end=100;
for(int i=1:i<=end;i++){
    total += i;
}

// 方式2：公式直接计算
int total=0;
int end=100;
total = (1+end) * end/2;
}
```

#### 时间频度比较之忽略常数项
- $T(n)=2n+20$ 与 $T_1(n)=2n$ 随着 $n$ 增大，两个函数的曲线无限接近，所以 $T(n) 的常数项可忽略。

#### 时间频度比较之忽略低次项
- $T(n)=2n^2+3n+10$ 和 $T_1(n)=2n^2$ 随着 $n$ 增大两个函数的曲线无限接近，所以 $T(n) 的低次项 $3n+10$ 可忽略。

#### 时间频度比较之忽略低次项
- $T(n)=5n^2+7n$ 和 $T_1(n)=3n^2 + 2n$ 随着 $n$ 增大两个函数的曲线无限接近，所以 $T(n) 与 $T_1(n) 的系数可忽略。


### 时间复杂度
- 什么是时间复杂度？ 
通常算法中的基本操作语句的重复执行次数是关于 $n$ 的函数，用 $T(n)$ 表示；
  - 若有某个辅助函数 $f(n)$；
  - 使得当 $n$ 趋近于无穷大时，$T(n)/f(n)$ 的极限值为不等于零的常数，则称 $f(n)$ 是 $T(n)$ 的同数量级函数。
记作 $T(n) = O(f(n))$，称 $O(f(n))$ 为算法的渐进时间复杂度，简称**时间复杂度**。

- 时间复杂度的特点
  - 不同的 $T(n)$，时间复杂度可能相同。
    - 如：$T(n)=n^2+7n+6$ 与 $T(n)=3n^2+2n+2$ 的 $T(n)$ 不同，但时间复杂度相同，都为 $O(n^2)$。
    
- 计算时间复杂度的方法
  - 用常数 1 代替运行时间中的所有加法常数：$T(n)=n^2+7n+6 => T(n)=n^2+7n+1$
  - 修改后的运行次数函数中，只保留最高阶项：$T(n)=n^2+7n+1 => T(n)=n^2$
  - 去除最高阶项的系数：$T(n)=n^2 => T(n)=n^2 => O(n^2)$

- 常见的时间复杂度
  - 常数阶 $O(1)$
  - 对数阶 $O(log2n)$
  - 线性阶 $O(n)$
  - 线性对数阶 $O(nlog2n)$
  - 平方阶 $O(n^2)$
  - 立方阶 $O(n^3)$
  - k 次方阶 $O(n^k)$
  - 指数阶 $O(2^n)$  
常见的算法时间复杂度由小到大依次为：$Ο(1)<Ο(log2n)<Ο(n)<Ο(nlog2n)<Ο(n^2)<Ο(n^3)<Ο(n^k)<Ο(2^n)$，随着问题规模 $n$ 的不断增大，时间复杂度不断增大，算法的执行效率越低。

- 什么是平均时间复杂度和最坏时间复杂度？
  - 所有可能的输入实例均以等概率出现的情况下，该算法的运行时间，称为**平均时间复杂度**。
  - 最坏情况下的时间复杂度称**最坏时间复杂度**。
  - 一般讨论的时间复杂度均是最坏情况下的时间复杂度。
    - 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上限，保证了算法的运行时间不会比最坏情况更长。
  - 平均时间复杂度和最坏时间复杂度是否一致与具体的算法有关。


## 空间复杂度
- 什么是空间复杂度？
算法所耗费的存储空间称为**空间复杂度**。

- 算法所占用的空间有哪些？
  - 算法本身占用的空间，输入、输出、指令、常数、变量等
  - 算法要使用的辅助空间
  
- 空间复杂度特点
  - 是对一个算法在运行过程中临时占用存储空间大小的量度。
  - 空间复杂度是关于 $n$ 的函数，随着 $n$ 的增大，占用的存储越大
    - 有的算法需要占用的 临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n
      - 你好


  
  
  