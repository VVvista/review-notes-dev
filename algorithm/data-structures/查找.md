[[toc]]
## 1.查找
- 什么是查找表？

有同一类型的数据元素（记录）构成的集合称为查找表。

- 什么是查找？

根据指定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录。

- 什么是关键字？  
用来标识一个数据元素或记录的某个数据项的值。
  - 可唯一标识一个记录的关键字称为主关键字
  - 用于识别若干记录的关键字称为次关键字
  
- 怎么判断查找是否成功？
  - 若查找表中存在这样一个记录，则称查找成功
    - 查找结果给出整个记录的信息，或指示该记录在查找表的位置 
  - 否则查找失败
    - 查找结果给出空记录或空指针

- 对查找表经常进行的操作：
  - 查询某个特定的数据元素是否在查找表中
  - 检索某个特定的数据元素的各种属性
  - 在查找表中插入一个数据元素
  - 删除查找表中的某个数据元素
  
- 查找表的分类
  - 静态查找表
    - 仅作查询（检索）操作的查找表
  - 动态查找表
    - 作插入和删除操作的查找表；
    - 有时在查询之后，还需要将查询结果为空的数据元素插入到查找表中；
    - 在查找表中删除其查询结果“在查找表中”的数据元素。

-如何评价查找算法？  
关键字的平均比较次数，称为平均查找长度 
$$ASL=\sum_{i=1}^n p_ic_i$$
  - $n$：记录的个数
  - $p_i$：查找第 $i$ 个记录的概率
  - $c_i$：找到第 $i$ 个记录所需的比较次数

- 查找过程中我们要研究什么？
  - **查找的方法取决于查找表的结构**，即表中数据元素是依何种关系组织在一起的。
  - 对于查找表，在集合中查询或检索一个特定的数据元素时，若无规律可循，只能对集合中的元素一一加以辨认直至找到为止。
  - 而这样的查询或检索是任何计算机应用系统使用频率都很高的操作，因此设法**提高查找表的查找效率**，是讨论的重点。
  - 为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间认为的加上某种确定的约束关系。
  
- 线性表的三种查找算法
  - 顺序查找（线性查找）
  - 折半查找（二分或对分查找）
  - 分块查找  

## 顺序查找
- 顺序查找的应用范围
  - 顺序表或线性链表表示的静态查找表
  - 表内元素之间无序

- 顺序查找算法
在顺序表 $ST$ 中查找值为key的数据元素(从最后一个元素开始比较)
```$xslt
int search(Table st,Key key){
  for (i=st.length;i>=1;--i){
  if(st[i].key==key) 
    return i;
  return 0;
 }
}  
```
- 顺序查找的性能分析
  - 时间复杂度：$O(n)$；
  - 空间复杂度：$O(1)$。
  
- 记录的查找概率不相等时如何提高查找概率？  
查找表存储记录原则--按查找概率存储
  - 查找概率高，比较次数越少；
  - 查找概率低，比较次数越多。
  
- 记录的查找概率无法测定时如何提高查找概率？
按查找概率动态调整记录顺序
  - 在每个记录中设一个访问频度域；
  - 始终保持记录按非递增有序的次序排列；
  - 每次查找后均将刚查到的记录直接移动表头。

- 顺序查找的特点
  - 优点：算法简单，逻辑次序无要求，且不同存储结构均使用；
  - 缺点：ASL 太长，时间效率太低。

## 折半查找
- 什么是折半查找？

 每次将待查记录所在区间缩减一半的查找方法称为**折半查找**。

- 折半查找的性能分析之判定数
  - 查找成功：
    - 比较次数 = 路径上的结点数
    - 比较次数 = 结点的层数
  - 查找不成功：
    - 比较次数 = 路径上的内部结点数
    - 比较次数 $\le |log2n| +1$ 

- 折半查找的特点
  - 优点：效率比顺序查找高。
  - 缺点：只适用于有序表，且限于顺序存储结构，对线性链表无效。


## 分块查找（索引顺序查找）
分块查找的条件：
  - 将表分成几块，且表或者有序，或者分块有序；
  - 若 $i\lt j$，则将 $j$ 块中所有记录的关键词均大于第 $i$ 块中的最大关键字；
  - 建立索引表；
    - 每个结点含有最大关键字域和指向本块第一个结点的指针；
    - 按关键字有序。
    
- 分块查找步骤：
  - 先确定待查记录在索引表中的块位置（顺序查找或折半查找）；
  - 在块内查找（顺序查找）。
  
- 分块查找性能分析  
查找效率：$ASL=L_b+L_w$
  - $L_b$：对索引表查找的 $ASL$；
  - $L_W$：对块内查找的 $ASL$；

- 分块查找的特点
  - 优点：插入和删除比较容易，无需进行大量移动；
  - 缺点：要增加一个索引表的存储空间，并对初始索引表进行排序算法；
  - 适用情况：如果线性表既要快速查找又经常动态变化，则可采用分块查找。


## 查找方法比较
|    | 顺序查找  | 折半查找  |  分块查找  |
| --------  | --------   | -----:   | :----: |
|ASL        | 最大      |   最小 | 中间   |
| 表结构 | 有序表、无序表  | 无序表 |   分块有序    |
| 存储结构 | 顺序表、线性链表  |顺序表   |   顺序表、线性链表   |


## 二叉排序树

###数表的查找
当表插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录。
改用动态查找表——几种特殊树
表结构再查好过程中动态生成：
- 对于给定值key，若表中存在，则成功返回；否则，插入关键字等于key的记录。

常见的特殊树：
- 二叉排序树、平衡二叉树、红黑树、b-树、b+树、键树

### 二叉排序树
二叉排序树：使用中序遍历是有序的

性质：中序遍历非空的二叉排序树所得到的的数据元素序列是一个按关键字排序的递增有序序列。

#### 二叉排序树的存储结构和递归实现

#### 二叉排序树算法分析
含有 n 个结点的二叉排序树的平均查找长度和树的形态有关
最好情况：与折半查找中的判定树相同。
最坏情况：插入的 n 个元素从一开始就有序——变成单枝树的形态，此时查找效率和顺序查找情况相同。

- 如何提高形态不均衡的二叉排序树的查找效率？
解决方法：做“平衡化处理”，即尽量让二叉树的形状均衡

### 二叉排序树的插入
- 若二叉排序树为空，则差软水结点作为根结点插入到空树中
- 否则，继续在其左右子树上查找
  - 树中已有，不再插入
  - 树中没有，查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子
### 二叉排序树的生成
不同插入次序的序列生成不同形态的二叉排序树

### 二叉排序树的删除
从二叉排序树中删除一个结点，不能把以该结点为根的子树都删除，只能删除该结点，并且还应保证删除后所得二叉树仍能满足二叉排序树的性质不变。
 由于中序遍历二叉排序树可以得到一个递增有序的序列。那么，在二叉排序树中删除一个结点相当于删除有序序列中的一个结点。
- 将因删除结点而断开的二叉链表重新连接起来
- 防止重新连接后的树增加高度

- 被删除的结点只有左子树或只有右子树，用其左子树或右子树替换他（结点替换）
- 被删除的结点既有左子树，也有右子树
  - 以其中序前驱值替换之（值替换），然后再删除该前驱结点。前驱是左子树中最大的结点
  - 也可以用其后继替换之，然后再删除该结点后继结点。后继是右子树中最小的结点

## 平衡二叉树（AVL 树）
一棵平衡二叉树或者空数，或者是具有下列性质的二叉排序树：
- 左子树与右子树的高度之差的绝对值小于等于1；
- 左子树和右子树也是平衡二叉树。
  
平衡因子：为了方便起见，给每个结点附加一个数字，给出该结点左子树和右子树的高度差。这个数字称为结点的平衡因子（BF）。
平衡因子 = 结点左子树的高度 - 结点右子树的高度 

判断平衡二叉树：对于一棵有 n 个结点的 AVL 树，其高度保持在 O(log2n) 数量级，ASL 也保持在 O(log2n) 数量级。

## 平衡二叉树调整

当在一个平衡二叉排序树上插入一个结点时，有可能导致失衡，即出现平衡因子绝对值大于 1 的结点。
如果在一棵 AVL 树中插入一个新结点后造成失衡，则必须调整树的结构，使之恢复平衡。

平衡调整的四种类型：LL LR RL RR

#### LL型调整过程
- B 结点带左子树 a 一起上升
- A 结点称为 B 的右孩子
- 原来 B 结点的右子树 b 作为 A 的左子树

#### RR型调整过程
- B 结点带右子树 b 一起上升
- A 结点称为 B 的左孩子
- 原来 B 结点的左子树 b 作为 A 的右子树












### 2.1无序表的顺序查找
### 2.2有序表的顺序查找

## 3.基于关键词的查找
### 3.1对半查找
### 3.2一致对半查找
### 3.3斐波那契查找
### 3.4插值查找

## 4.二叉查找树
### 4.1查找、插入和删除
### 4.2平均情况时间分析

## 5.最优二叉查找树
### 5.1访问频率
### 5.2最优二叉查找树
### 5.3近似最优树的构造

## 6.线性表的查找

## 7.数表的查找

## 8.数列表的查找