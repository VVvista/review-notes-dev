[[toc]]
## 1.图的定义
**图**：$$G=(V,E)$$

**$V$**:顶点(数据元素)的有穷非空集合;$E$:边的有穷集合

**无向图**：每条边都是无方向的

**有向图**：每条边都是有方向的

![tt](_images/图_示例图.png "tt")

**完全图**：任意两个点都有一条边相连

**无向完全图**：$n$个顶点，$n(n-1)\over 2$条边

**有向完全图**：$n$个顶点，$n(n-1)$条边

![tt](_images/图_完全图.png "tt")

**顶点的度**：与该顶点相关联的边的数目

**入度**：以该顶点为终点的有向边的条数

**出度**：以该顶点为始点的有向边的条数

**在有向图中，顶点的度等于该顶点的入度和出度之和**

**稀疏图**：有很少边或弧的图

**稠密图**：有较多边或弧的图

**网**：边/弧带权的图

**邻接**：有边/弧相连的两个顶点之间的关系。存在$(v_i,v_j)$则称$v_i$和$v_j$互为邻接点；$<v_i,v_j>$则称$v_i$邻接到$v_j$，$v_j$邻接于$v_i$

**关联**：边/弧与顶点之间的关系。存在$(v_i,v_j)$/$<v_i,v_j>$,则称该边/弧关联于$v_i$和$v_j$

**路径**：连续的边构成的顶点序列

**路径长度**：路径上的边或弧的数目/权值之和

**回路**：第一个顶点和最后一个顶点相同的路径

**简单路径**：除路径起点和终点可以相同外，其余顶点均不相同的路径

**简单回路**：除路径起点和终点相同外，其余顶点均不相同的路径

![tt](_images/图_路径.png "tt")

**连通图(强连通图)**：在无(有)向图$G=(V,E)$ 中，若对任何两个顶点$v$ 、$u$都存在从$v$到$u$的路径，则称$G$是连通图(强连通图)

![tt](_images/图_连通图.png "tt")

**子图**：设有两个图，$G=(V,E)$、$G1=(V1,E1)$，若$V1 \subseteq V $,$E1 \subseteq E$,则称$G1$是$G$的子图

**极大(强)连通子图**：子图$G1$是$G$连通子图，将$G$的任何不在子图中的顶点加入，子图不再连通

**连通分量(强连通分量)**：无(有)向图$G$的极大连通子图称为$G$的连通分量

**极小连通子图**：该子图是$G$的连通子图，在该子图中删除任何一条边/弧，子图不再连通

**生成树**：包含无向图$G$所有顶点的极小连通子图

**生成森林**：对非连通图，由各个连通分量的生成树的集合

## 2.图的存储结构
**图的逻辑结构**：多对多

**图没有顺序存储结构，但可以借助二维数组来表示元素见的问题**

### 2.1邻接矩阵
**邻接矩阵表示法**：建立一个顶点表(记录各个顶点信息)和一个邻接矩阵(表示各个顶点之间的关系)

#### 2.1.1无向图的邻接矩阵表示法
* 设图$A=(V,E)$有$n$个顶点，则顶点表$Vexs[n]$定义为：

$$
\begin{array}{c|lcr}
i & 0 & 1 & 2 & ... & {n-1} \\
\hline
Vexs[i] & V_1 & V_2 & ... & V_n \\
\end{array}
$$

*图的邻接矩阵是一个二维数组$A.arcs[n][n]$定义为：

$$
A.arcs[i][i]=
\begin{cases}
1, &如果(i,j) \in E \\
0, &其他
\end{cases}
$$

**特点**：
1. 无向图的邻接矩阵是对称的
1. 顶点$i$的度=第$i$行(列)中1的个数
1. 完全图的邻接矩阵中，对角元素为0，其余为1

#### 2.1.2有向图的邻接矩阵表示法
*有向图的邻接矩阵$A.arcs[n][n]$定义为：

$$
A.arcs[i][i]=
\begin{cases}
1, &如果<i,j> \in E \\
0, &其他
\end{cases}
$$

**在有向图的邻接矩阵中**：
1. 第$i$行含义：以结点$i$为尾的弧(即出度边)
1. 第$i$列含义：以结点$i$为头的弧(即入度边)

**特点**：
1. 有向图的邻接矩阵可能不对称
1. 顶点的出度=第$i$行元素之和
1. 顶点的入度=第$i$列元素之和
1. 顶点的度=第$i$行元素之和+第$i$列元素之和

#### 2.1.3有权图的邻接矩阵表示法
网的邻接矩阵$A.arcs[n][n]$定义为：

$$
A.arcs[i][i]=
\begin{cases}
E_{ij}, &<i,j> 或(i,j) \in E \\
\infty , &无边/弧
\end{cases}
$$

#### 2.1.4邻接矩阵总结
**算法思想**：
1. 输入总顶点数和总边数
1. 依次输入点的信息存储在顶点表中
1. 初始化邻接矩阵，初始化每个权限

**邻接矩阵的优点**：适合完全图
1. 直观、简单、好理解
1. 便于查找任意两个顶点是否存在变
1. 便于查找任意顶点的所有邻接点
1. 便于计算任意顶点的度

**邻接矩阵的缺点**：
1. 不便于增加和删除顶点
1. 浪费空间：稀疏图的存储浪费空间
1. 浪费时间：统计稀疏图共有多少边

### 2.2邻接表
**邻接表表示法(链式)**

 **基本思想**：
 1. 顶点：按编号顺序将顶点数据存储在一维数组中
 1. 关联同一顶点的边：用线性链表存储
 
#### 2.2.1无向图的邻接表
【插图-解析】

**特点**：
1. 邻接表不唯一
1. 若无向图有$n$个顶点，$e$条边，则其邻接表需$n$个头结点和$2e$个表结点。适合存储稀释图

#### 2.2.2有向图的邻接表
* **邻接表**：找出度容易，找入度难

【插图-解析】

**特点**：
1. 顶点$V_i$的出度：第$i$个单链表中的结点个数
1. 顶点$V_i$的入度：整个单链表中邻接点域值是$i-1$的结点个数

* **逆邻接表**：找入度容易，找出度难

【插图-解析】

**特点**：
1. 顶点$V_i$的入度：第$i$个单链表中的结点个数
1. 顶点$V_i$的出度：整个单链表中邻接点域值是$i-1$的结点个数

#### 2.2.3邻接表总结
算法思想：
1. 输入总顶点数和总边数
1. 建立顶点表，依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为null
1. 创建邻接表，依次输入每条边衣服的两个顶点，确定两个顶点的序号i和j，建立边结点，将此边结点分别插入到$v_i$和$v_j$对应的两个边链表的头部

【插图-解析】

邻接表与邻接矩阵的关系：
邻接表特点：
1. 方便找任一顶点的所有邻接点
1. 节约稀疏图的空间。需要$n$个头指针和$2e$个结点
1. 方便计算任一顶点的度
1. 不方便检查任意一对顶点间是否存在边

邻接表与邻接矩阵：
联系： 邻接表中每个链表对应邻接矩阵的一行，链表中结点个数等于一行中非零元素的个数
区别： 1. 对于任一确定的无向图，邻接矩阵时唯一的，但邻接表不唯一
2. 邻接矩阵的空间复杂度为$O(n^2)$,邻接表的空间复杂度为$n+2e$
用途： 邻接矩阵多用于稠密图，邻接表多用于稀疏图

**十字链表**：有向图的结点求度难
【插图-存储方式】
**邻接多重表**：无向图每条边都要存储两遍
顶点结点：data和firstedge。data存与顶点有关的信息，firstedge指向第一条依附于该顶点的边
边结点：
【插图-存储方式】

## 3.图的遍历
从一直的连通图中的某个顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，叫做图的遍历。
遍历实质：找每个顶点的邻接点的过程

因为图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的结点。
因此设置辅助数组$visited[n]$用来标记每个被访问过的顶点，初始状态中$visited[i]=0$，顶点$i$被访问过后，$visited[i]=1$，从而避免被多次访问

### 3.1深度优先遍历
深度优先搜索DFS：
遍历过程：
【插图-遍历演示】
遍历实现：
遍历结果：
代码实现：
```
void DFS(AMGraph G, int v){ // 图G为邻接矩阵类型
visited[v]=true; // 访问第v个顶点
for(w=0;w<G.vexnum;w++){// 依次检查邻接矩阵v所在的行
if(G.arcs[v][w]!=0&& !visited[w]){
DFS(G,W);
// w为v的邻接点，如果w未访问，则递归调用DFS
}}}
```
用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描到该顶点所在行，时间复杂度为$O(n^2)$

非连通图的遍历：

### 3.2广度优先遍历
广度优先搜索BFS：
从图的某一个结点出发，首先依次访问该节点的所有相邻的结点，再按这些结点被访问的先后次序依次访问与他们相邻所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止。

【插图-遍历演示】
非连通图的广度遍历：


使用循环队列实现广度优先遍历：
遍历结果：


### 3.3邻接表的遍历算法
邻接表表示图，虽然有$2e$个表结点，但只需扫描$e$个结点即可完成遍历，加上访问$n$个头结点的时间，时间复杂度为$O(n+e)$
结论：稠密图适用于在邻接矩阵上进行深度遍历，稀疏图适用于邻接表上进行深度遍历
效率比较：
1. 空间复杂度相同，都是$O(n)$(借用了堆栈或队列)
1. 时间复杂度至于存储结构(邻接矩阵或邻接表)有关，而与搜索路径无关

## 4.最小生成树
### 4.1生成树
生成树：所有顶点均由边连接在一起，但不存在回路的图
【插图】

一个图可以有多棵不同的生成树。所有的生成树具有以下共同特点：
1. 生成树的顶点个数与图的顶点个数相同
1. 生成树是图的极小连通子图，去掉一条边则非联通
1. 一个有n个顶点的连通图的生成树有$n-1$条边
1. 在生成树中再加一条边必然形成回路
1. 生成树中任意两个顶点间的路径是唯一的

注意：
1. 有n个顶点$n-1$条边的图不一定是生成树

**无向图的生成树**
深度优先生成树：
广度优先生成树：
【插图】

### 4.2最小生成树
给定一个无向网络，在该网的所有生成树中，使得各边权值之和之和最小的那棵生成树称为该网的最小生成树，也称为最小代价最小代价生成树
最小生成树可能不唯一

### 4.3构造最小生成树
MST性质：设$N=(V,E)$是一个连通图，$U$是顶点集$V$的一个非空子集。若边$(u,v)$是一条具有最小权值额边，其中$u U$,$v V-U$，则必存在一棵包含边$(u,v)$的最小生成树。
【插图-演示】

在生成树的构造过程中，图中$n$个顶点分属于两个集合：
* 已落在生成树上的顶点集
* 尚未落在生成树上的顶点集

#### 4.3.1构造最小生成树-prim算法
算法思想：
设$N=(V,E)$是一个连通网，$TE$是$N$上最小的生成树中的边的集合；
初始一个$TE={}$集合，然后找到一个结点，然后$TE$、$U-TE$集合找到最小权重的边，继续前两步
【插图-演示】

#### 4.3.2构造最小生成树-Kruskal算法
算法思想：
1. 设$N=(V,E)$是一个连通网，令最小生成树初始状态为只有$n$个顶点而无边的连通图$T=(V,{})$，每个顶点自成一个连通分量
1. 在设$E$中选取代价最小的边，若该边依附的顶点落在$T$中不同的连通分量上（不能形成环），则将该边加入到$T$中，否则舍去该边，选取下一条代价最小的边
1. 以此类推，直至$T$中所有顶点都在同一个连通分量中为止
【插图-演示】

#### 4.3.3构造最小生成树-算法比较
prim算法：选择点，时间复杂度：$O(n^2)$($n$为顶点数)，适用于稠密图
Kruskal算法：选择边，时间复杂度：$O(eloge)$($e$为边数)，适用于稀疏图

## 5.最短路径问题
在有向网中使A点到B点的多条路径中，寻找一条各边权值之和最小的路径，即为最短路径

### 5.1两点间最短路径-Dijkstra(迪杰斯特拉)算法
步骤：
1. 找到权值最小的边结点
1. 对于该结点的邻居，检查是否有前往他们最短的路径，如果有记录其距离
1. 重复上述过程，直到图中的每个结点的最短路径都找到
1. 计算最终路径

【插图-演示】

### 5.2某源点到其他各点最短路径-Floyd(弗洛伊德)算法
步骤：
1. 初始设置一个$n$阶方阵，令其对角线元素为0，若存在弧$<v_i,v_j>$，则对应元素为权值；否则为无穷
1. 逐步在原直接路径中增加中间顶点，如加入中间顶点后路径变短，则修改之；否则维持原值。
1. 所有顶点试探完毕，算法结束

【插图-演示】

## 6.关键路径
AOE网解决关键路径：
关键路径：路径最长的路径
路径长度：路径上各活动持续时间之和
关键路径的4个描述量：
1. $ve(v_j)$：表示事件$v_j$最早发生的时间
1. $vl(v_j)$：表示事件$v_j$最迟发生的时间
1. $e(i)$：表示活动$a_i$最早开始的时间
1. $l(i)$：表示活动$a_i$最迟开始的时间
1. $l(i)-e(i)$:表示完成活动$a_i$的时间余量

$ve(j)=max$

【插图-演示】


----以下为参考内容
## 4.拓扑排序
## 6.最短路径问题
### 6.1无权最短路径问题
### 6.2有权最短路径问题
### 6.3每对顶点之间的最短路径问题
### 6.4满足约束的最短路径

## 8.图的应用