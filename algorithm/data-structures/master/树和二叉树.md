[[toc]]
## 树的定义和基础术语
### 树的定义
**树**：具有$n(n\ge 0)$个结点的有限集

![tt](_images/树_示例图.png "tt")

* **空数**：$n=0$
* 仅有一个特定的成为根的结点, 其余结点可分为$m(m\ge 0)$个互不相交的有限集，其中每一个集合本身又是一棵树，并成为根的子树

### 树的基础术语
**根结点**：非空树中无前驱结点的结点

**结点的度**：结点拥有的子树数

**树的度**：树内各结点的度的最大值

**树的深度**：树中结点的最大层次

**结点的子树的根成为该结点的孩子，该结点称为孩子的双亲**

**叶子**：终端结点

**内部结点**：根结点以外的分支结点

**非终端结点**：度不为0的分支结点

**有序树**：树中结点的各子树从左到右有次序

**无序树**：树中结点的各子树无次序

**森林**：$m(m\ge 0)$棵互不相交的树的集合

* 一棵树可以看成一个特殊的森林
* 森林中的各子树加上一个双亲结点，森林便变成了树

### 树结构和线性结构的比较
**线性结构**：第一个元素无前驱，最后一个元素无后继，其他元素仅有一个前驱一个后继，数据一对一

**树结构**：根结点无双亲，叶子结点无孩子，其他结点仅一个双亲多个孩子，数据一对多

[[toc]]
## 二叉树
**二叉树**：由$n(n\ge 0)$个结点组成的有限集，除空集外，每一个根结点及两棵互不相交的分别称为这个根的左子树和右子树

![tt](_images/树_二叉树.png "tt")

**特点**：
* 二叉树的度不超过2
* 子树有左右之分，其次序不能颠倒
* 二叉树可以是空集，根也可以有空的左子树或空的右子树

**二叉树与树的区别**：
1. 二叉树不是树的特殊情况
2. 二叉树节点的子树要区分左子树或右子树；树结点只有一个孩子时，无需分区其左右次序。

**案例**：
1. 数据压缩-编码
2. 利用二叉树求解表达式的值

**二叉树的性质**：
1. 在二叉树的第i层上最多有$2^(i-1)$个结点,最少有1个结点
2. 深度为k的二叉树最多有$2^i-1$个结点($k\ge 1$)
3. 对任何一颗二叉树$T$,如果其叶子数为$n_0$,度为2的结点数为$n_2$，则$n_0=n_2+1$

**满二叉树**：一棵树深度为$k$且有$2^k-1$个结点($k\ge 1$)的二叉树

![tt](_images/树_满二叉树.png "tt")

**特点**：
1. 每一层上的结点数都是最大结点数
2. 叶子结点全部在最底层

**满二叉树结点位置的编码规则**：从根结点开始，自上而下，自左而右；每一个结点位置都有元素

**完全二叉树**：($k\ge 1$)

![tt](_images/树_完全二叉树.png "tt")

**完全二叉树**：深度为k的具有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$k$的满二叉树的编号$1\to n$的结点一一对应

**在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完成二叉树**

**特点**：
1. 叶子只能分布在层次较大的两层上
2. 对任一结点，如果其右子树的最大层次为$i$，则左子树的最大层次必为$i$或$i+1$

**性质**：
1. 具有n个结点的完全二叉树的深度为$\lfloor log_{2n} \rfloor +1$

### 二叉树顺序存储
**二叉树顺序存储**：按满二叉树的结点层次编号，依次存放二叉树中的数据元素

![tt](_images/树_完全二叉树.png "tt")

**存储格式**：
$$
\begin{pmatrix}
1&2$3$4$5$6$7$8$9$10$11$12\\
\end{pmatrix}
$$

**缺点**：
1. 只适合存储满二叉树或完全二叉树，最坏情况：深度为k的且只有k个结点的单支树需要长度为$2^k-1$的数组

### 二叉树链式存储
**二叉树链式存储**：每个结点由数值域，左子树指针、右子树指针组成

![tt](_images/树_二叉树指针域.png "tt")

![tt](_images/树_二叉树链式存储.png "tt")

在$n$个结点的二叉链表中，有$n+1$个空指针域

### 二叉树遍历
**遍历**：顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次
**方法**：依次遍历二叉树中的三个组成部分，便是遍历了整个二叉树

#### 先序遍历
**步骤**：若二叉树为空，则空操作
1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树
![tt](_images/树_二叉树遍历.png "tt")

先序遍历结果：$ABELDHMIJ$

* 先序遍历递归算法
```
void preOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    visit(T);// 访问根结点
    preOrderTraverse(T->lchild);//递归遍历左子树
    preOrderTraverse(T->rchild);//递归遍历右子树
    }
}
```
* 先序遍历非递归算法

#### 中序遍历
**步骤**：若二叉树为空，则空操作
1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

![tt](_images/树_二叉树遍历.png "tt")

中序遍历结果：$ELBAMHIDJ$

* 中序遍历递归算法
```
void inOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    inOrderTraverse(T->lchild);//递归遍历左子树
    visit(T);// 访问根结点
    inOrderTraverse(T->rchild);//递归遍历右子树
    }
}
```

* 中序遍历非递归算法

基本思想：
1. 建立一个栈
2. 根结点进栈，遍历左子树
3. 根结点出栈，输出根结点，遍历右子树
```
void inOrderTraverse(BiTree T){
  【算法实现】
}
```

#### 后序遍历
**步骤**：若二叉树为空，则空操作
1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

![tt](_images/树_二叉树遍历.png "tt")

后序遍历结果：$LEBMIHJDA$

* 后序遍历递归算法
```
void inOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    inOrderTraverse(T->lchild);//递归遍历左子树
    inOrderTraverse(T->rchild);//递归遍历右子树
    visit(T);// 访问根结点
    }
}
```
* 后序遍历非递归算法

#### 先/中/后序遍历应用
* 数值表达式的前缀(波兰式)/中缀/后缀(逆波兰式)表达式

![tt](_images/树_波兰表达式.png "tt")

遍历结果：
1. 先序(波兰式)：$-*abc$
1. 中序：$a*b-c$
1. 后序(逆波兰式)：$ab*c-$

* 由遍历序列确定二叉树

1.已知先序和中序序列求二叉树

先序序列：$ABCDEFGHIJ$

中序序列：$CDBFEAIHGJ$

**特点：先序遍历，根结点必在先序序列头部**

![tt](_images/树_先序中序.png "tt")

2.已知中序和后续序列求二叉树

中序序列：$BDCEAFHG$

后序序列：$DECBHGFA$

**特点：后序遍历，根结点必在先序序列尾部**

![tt](_images/树_中序后序.png "tt")

* 先/中/后序遍历递归算法总结

**三种遍历的递归算法中每个结点都经过三次，且访问的路径是相同，只是访问结点值的时机不同。**

![tt](_images/树_二叉树遍历总结.png "tt")

1. 先序遍历：第1次经过时访问
2. 中序遍历：第2次经过时访问
3. 后序遍历：第3次经过时访问

**时间效率**：$O(n)$// 每个结点只访问一次

**空间效率**：$O(n)$// 栈占用的最大辅助空间

#### 层次遍历
**层次遍历**:从根结点开始，按从上到下、从左到右的顺序访问每一个结点(每个算法只访问一次)

![tt](_images/树_二叉树层次遍历.png "tt")

层次遍历结果：$abfcdgeh$

**基本思想**：使用一个队列
1. 将根节点进队
2. 队不为空时循环：从队列中出列一个结点p，访问它

   2.1 若它有左孩子结点，将左孩子结点进队
   
   2.2 若它有右孩子结点，将右孩子结点进队

```
void levelOrder(BTNode T){
  【算法实现】
}
```


## 线索二叉树
问题：当用二叉链表作为二叉树的存储结构时，可以很方便的找到结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前驱和前驱和后继结点

### 线索二叉树的操作
**线索**：二叉链表的存储中存在空指针域，如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱，如果结点的右孩子为空，则将空的右孩子指针域改为指向其后继

**线索二叉树**：加上了线索的二叉树

**将二叉树按某种遍历次序使其变为线索二叉树的过程称为线索化。**

**二叉树的遍历-存储:**

![tt](_images/树_线索二叉树.png "tt")

为了区分左指针和右指针指向的是孩子还是前驱或后继，在二叉链表中每个结点增设两个标志域ltag和rtag：
1. ltag=0 ：左指针指向该结点的左孩子
1. ltag=1 ：左指针指向该结点的前驱
1. rtag=0 ：右指针指向该结点的右孩子
1. rtag=1 ：右指针指向该结点的后继

* 先序线索二叉树
* 中序线索二叉树
* 后序线索二叉树

**增设头结点**：
1. ltag=0，左指针指向根结点
1. rtag=1，右指针指向遍历序列中最后一个结点

遍历序列中第一个结点的左指针域和最后一个结点的右指针域均指向头结点

![tt](_images/树_线索二叉树链式存储.png "tt")

