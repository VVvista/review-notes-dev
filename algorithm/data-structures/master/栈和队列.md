[[toc]]
## 栈
**栈**：只能在表的同一端进行插入和删除操作，且操作遵循先进后出的原则。进行插入和删除的一端为栈顶，另一端为栈底。栈为操作受限的线性表，当栈中无元素时称为空栈

![tt](_images/栈_示例图.png "tt")

假设栈$S=(a_1,a_2,a_3,...,a_n)$ ,则$a_1$为栈底元素，$a_n$为栈顶元素，插入数据到栈顶的操作成为入栈，从栈顶删除最后一个元素操作成为出栈。因此栈具有先进后出的原则。

**栈与一般线性表的区别**：仅在于运算规则不同。栈是先进后出，线性表是随机存取。

**基本操作**：
1. 压入一个元素
2. 弹出一个元素
3. 存取栈顶元素值
4. 清空栈
5. 判断栈是否为空

**常见情景**：
1. 数制转换
2. 表达式求值
3. 括号匹配的检验
4. 八皇后问题
5. 行编辑程序
6. 函数调用
7. 迷宫求解
8. 递归调用实现

### 顺序栈
**顺序栈**：用顺序存储方式实现的栈称为顺序栈

利用一组地址连续多的存储单元依次存放自栈底到栈顶的数据元素，栈底一般在低地址端。
* 设top指针，指示栈顶元素在顺序栈中的位置；实际操作中top指向真正栈顶元素之上的下标地址
* 设base指针，指示栈底元素在顺序栈中的位置
* 用stackSize表示栈的最大容量
* 在初始化栈时，先为栈分配一个基本容量，然后在应用的过程中，当栈的空间不够使用时再逐渐扩大。

![tt](_images/栈_顺序栈.png "tt")

**空栈**：base==top
**栈满**：top-base=stackSize

### 链式栈
**链式栈**：用链表存储方式实现的栈称为链式栈

链栈是运算受限的单链表，只能在链表头部进行操作；注意链栈中指针的方向

![tt](_images/栈_链栈.png "tt")

**特点**：
1. 链栈不需要头结点，链表的头指针就是栈顶
1. 基本不存在栈满的情况，空栈相当于头指针指向空
1. 插入和删除仅在栈顶处执行

### 栈应用
1. 进制转换
1. 括号匹配的检验
1. 迷宫求解
1. (逆)波兰表达式求值

[[toc]]
## 队列
只能在表的一端进行插入，另一端进行进行删除，且操作具有先进先出的原则的线性表成为**队列**

![tt](_images/队列_示意图.png "tt")

在队列中进行删除的一端称为队头，进行插入的一端称为队尾。假设栈$S=(a_1,a_2,a_3,...,a_n)$ ,则$a_1$为队头元素，$a_n$为队尾元素；没有元素的队列称为空队列。队列是一种受限的线性表。插入数据到队尾的操作成为入队，从队头删除最后一个元素操作成为出队

**队列基本操作**：
1. 向队尾添加元素
1. 删除队首元素
3. 获取队首的元素值
4. 判断队列是否为满
5. 判断队列是否为空
### 双端队列
限定插入和删除操作在表的两端进行的线性表称为**双端队列**

![tt](_images/队列_双端队列.png "tt")

也可以有输出受限的双端队列(一个端点只允许插入和删除，另一个端点只允许插入)和输入受限的双端队列(一个端点只允许插入和删除，另一个端点只允许删除)。同时双端队列也可以退化成栈，即只能在一端进行插入和删除。

### 顺序队列
**顺序队列**：用顺序存储方式存储的队列为顺序队列
【插图】

**删除队列头元素的两种方式**：
* 不要求队头元素必须存放在数组的一个位置。每次删除队头元素，只需要修改队头指针所指的位置。
* 要求队头元素必须存放在数组的第一个位置。每次删除队头元素，令所有的元素都向前移动一个位置。

### 循环队列
队列在线性存储时，当队尾指针指向队列最后一个位置末时不能在插入新的元素，而队列的实际可用空间未占满时，将队头与队尾连接形成闭环，此时成队列为**循环队列**
![tt](_images/队列_循环队列.png "tt")

判断队列满的两种方式：
1. 设置一个变量存储队列元素的个数，以此来判断队列为空或满
1. 少用一个元素空间，当队列头指针在队尾指针的下一位置时，队列为满。

### 链式队列
用链接存储方式实现的队列称为**链式队列**

![tt](_images/队列_链式队列.png "tt")

链式队列中需要首尾指针分别指向队首和队尾，并在队首添加头结点，并使头指针指向头结点。链式队列的插入和删除只需修改尾指针即可。

![tt](_images/队列_链式的操作.png "tt")


## 队列的应用


## 递归
**递归**：
* 若一个对象部分地包含自己，或用自己做给自己定义，则称该对象为递归
* 若一个过程直接地或间接地调用自己，则称该过程为递归过程
例如熟悉的阶乘函数：
$$
Fact(n)=
\begin{cases}
1, & 若 n=0\\[5ex]
n * Fact(n-1), & n>0
\end{cases}
$$

常见的程序代码：
```
long fact(参数){
    if(递归结束条件) 可直接求解步骤; // 基础项
    else fact(较小参数); // 归纳项
}
```
递归求n的阶乘：
```
long fact(long n){
    if(n==0) return 1;
    else return n * fact(n-1);
}
```

**常用到递归的情况**：
1. 递归定义的数学函数
1. 具有递归特性的数据结构
1. 可递归求解的问题
1. 汉诺塔问题

**优点**：结构清晰，程序易读

**缺点**：每次调用要生成新的存储空间，保存状态信息，时间开销大
