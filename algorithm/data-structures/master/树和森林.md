
## 数和森林
**树**：具有n(n>=0)个结点的有限集

**森林**：m(m>=0)个互不相交的树的集合

![tt](_images/树.png "tt")

![tt](_images/树_森林.png "tt")

### 树的存储结构
#### 双亲表示法
**双亲表示法**：定义结构数组存放数的结点，每个结点包含数据域和双亲域。

**数据域**：存放结点本身信息

**双亲域**：指示本结点的双清结点在数组中的位置

![tt](_images/树_双亲表示法.png "tt")

**特点**：找双亲容易，找孩子难

#### 孩子链表
**孩子链表**：把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。则$n$个结点由n个孩子链表（叶子的孩子链表为空表）。$n$个头指针又组成一个线性表，用顺序表存储。

![tt](_images/树_孩子链表.png "tt")

**特点**：找孩子容易，找双清难

#### 二叉链表表示法
**二叉链表表示法**：用二叉链表作树的存储结构，链表中每个结点含有两个指针域：左指针指向第一个孩子结点，右指针指向下一个兄弟结点

![tt](_images/树_二叉链表表示法.png "tt")

### 树和二叉树的转换
#### 树转换成二叉树
**步骤**：(兄弟相连留长子)
1. 加线：在兄弟之间加一连线
1. 抹线：对每个结点，除其左孩子外，去除其与其他孩子之间的关系
1. 旋转：以树的根结点为轴心，将树顺时针转45度

#### 二叉树转换成树
**步骤**：(左孩右右连双亲)
1. 加线：若$p$结点是双亲结点的左孩子，则将$p$的右孩子，右孩子的右孩子..沿分支找到的所有右孩子，都与$p$的双亲用线连起来
1. 抹线：去除原二叉树中双亲与右孩子之间的连线
1. 调整：将结点按层次排列，形成树结构

### 森林和二叉树的转换
#### 森林转二叉树
**步骤**：(树变二叉根相连)
1. 将各棵树分别转换成二叉树
1. 将每棵树的根结点用线相连
1. 以第一棵树的根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构

#### 二叉树转森林
**步骤**：(去掉全部右孩先，孤立二叉再还原)
1. 抹线：将二叉树中根结点与其右孩子连线，沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树
1. 还原：将孤立的二叉树还原成树

![tt](_images/树_森林二叉树转换.png "tt")

### 树和森林的遍历
#### 树的遍历
1. 先根遍历： 若树不为空，先访问根结点，再依次先根遍历各棵子树
1. 后根遍历： 若树不为空，先依次遍历各棵子树，再访问根结点
1. 层次遍历： 若树不为空，自上而下、自左至右访问树中每个结点

#### 森林的遍历
将森林看做三个部分组成：
1. 森林中第一棵树的根结点
1. 森林中第一棵树的子树森林
1. 森林中其他树构成的森林

**森林的遍历**：
1. 先序遍历： 若树不为空，依次从左到右对森林中的每一棵树进行先根遍历
1. 中序遍历： 若树不为空，依次从左到右对森林中的每一棵树进行后根遍历



## 赫夫曼树
### 基础概念
**路径**：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径

**结点的路径长度**：两结点间路径上的分支数

**树的路径长度**：从树根到每一个结点的路径长度之和

**权**：将树中结点赋给一个有着某种含义的数值，则该值成为结点的权

**结点的带权路径的长度**：从根结点到该结点之间的路径长度与该结点的权的乘积

**树的带权路径长度**：树中所有叶子结点的带权路径长度之和

**最优二叉树**：带权路径长度最短的二叉树

### 赫夫曼树构造算法
#### 构造算法
**赫夫曼树中权越大的叶子离根越近**

**构造方法**：
1. 构造森林全是根
1. 选用两小造新树
1. 删除两小造新人
1. 重复2、3剩单根

![tt](_images/树_赫夫曼树.png "tt")

**总结**：
1. 包含n棵树的森林要经过$n-1$次合并才能形成赫夫曼树，共产生$n-1$个新结点，且该$n-1$个新结点都具有两个孩子的分支结点
1. 赫夫曼树共有$2n-1$个结点，且所有分支结点的度均不为1

#### 构造算法实现
**采用顺序存储结构，使用一维结构数组**

**权重**：双亲结点下标：左孩子结点下标：右孩子结点下标

![tt](_images/树_赫夫曼树构造算法.png "tt")

#### 赫夫曼编码
**要求**：使用不定长编码，且任意字符的编码都不是另一个字符编码的前缀

**赫夫曼编码**：
1. 统计字符集中每个字符出现的平均概率（频率越大，编码越短）
1. 将每个字符的概率值作为权值构造赫夫曼树(概率越大，路径越短)
1. 在赫夫曼树的每个分支上标0或1： 左分支为0，右分支为1；把从根结点到每个叶子的路径上的标号连接起来，作为该叶子的字符编码

![tt](_images/树_赫夫曼树编码.png "tt")

**解码**：
1. 构造赫夫曼树
1. 依次读入二进制码，一旦到达某叶子结点时，即可译出字符
1. 再从根结点出发继续译码，直到结束

