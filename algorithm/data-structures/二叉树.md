[[toc]]
## 二叉树是什么
- 什么是二叉树？  
由 $n(n\ge 0)$ 个结点组成的有限集，每一个根结点最多有两棵互不相交的子树，这样的树称为**二叉树**。
  - 当 $n = 0$ 时称为**空树**；
  - 有且只有一个称为根的结点；
  - 除根结点以外的其余结点分为两个互不相交的子集 $T1$ 和 $T2$。
    - $T1$ 称为根的左子树；
    - $T2$ 称为根的右子树；
    - $T1$ 和 $T2$ 又可以看作二叉树。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树.png">
    <p>二叉树</p>
</div>

- 二叉树的特点
  - 二叉树的度不超过 2。
  - 子树有左右之分，其次序不能颠倒。
  - 二叉树可以是空集，根也可以有空的左子树或空的右子树。

- 二叉树与树的区别  
二叉树不是树的特殊情况：
  - 二叉树每个结点最多有两棵子树，而树结点的子树可以有无数棵；
  - 二叉树结点的子树要区分左子树或右子树，次序不能任意颠倒；树结点只有一个孩子时，没有左右次序之分。

- 二叉树的性质有哪些？
  - 在二叉树的第i层上最多有 $2^(i-1)$ 个结点，最少有 1 个结点。
  - 深度为 $k$ 的二叉树最多有 $2^i-1$ 个结点( $k\ge 1$ )。
  - 对任何一棵二叉树 $T$，如果其叶子数为 $n_0$，度为 2 的结点数为 $n_2$ 个，则 $n_0 = n_2 + 1$。证明如下：
    - 二叉树结点总数：$n = n_0 + n_1 + n_2$；
    - 除了根结点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n = B + 1$；
    - 由于树的分支是由度为 1 或 2 的结点射出，所以 $B = n_1 + 2 * n_2$
    - 综上所述：${n = n_1 + 2 * n_2 + 1} \Rightarrow n_0 = n_2+1$

#### 满二叉树是什么
- 什么是满二叉树？

一棵深度为 $k$ 且有 $2^k-1$ 个结点( $k\ge 1$ )的二叉树称为**满二叉树**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_满二叉树.png">
    <p>满二叉树</p>
</div>

- 满二叉树的特点  
从根结点开始，自上而下、自左而右，满二叉树具有如下特点：
  - 每一层上的结点数都是最大结点数
  - 叶子结点全部在最底层
  
#### 完全二叉树是什么
- 什么是完全二叉树？

深度为 $k$ 的具有 $n$ 个结点的二叉树，当且仅当其每一个结点都与深度为 $k$ 的满二叉树的编号 $1\to n$ 的结点一一对应的二叉树称为**完全二叉树**。  
简而言之，在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完成二叉树.

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_完全二叉树.png">
    <p>完全二叉树</p>
</div>

- 完全二叉树的特点
  - 叶子只能分布在层次较大的两层上；
  - 对任一结点，如果其右子树的最大层次为 $l$，则左子树的最大层次必为 $l$ 或 $l+1$。

- 完全二叉树的性质
  - 具有 $n$ 个结点的完全二叉树的深度为 $\lfloor log_{2n} \rfloor +1$。
  - 如果对一棵有 $n$个 结点的完全二叉树的结点按层次编号，则对任一结点：
    - 若 $i=1$，则该结点便是二叉树的根；
    - 若 $i>1$，则其双亲的结点编号为 $i/2$；
    - 若 $2i>n$，则该结点无左孩子，即该节点为叶子结点；否则其左孩子结点为 $2i$；
    - 若 $2i+1>n$，则该结点无右孩子；否则其左孩子结点为 $2i+1$。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_完全二叉树结点.png">
    <p>完全二叉树结点</p>
</div>

## 二叉树存储
### 二叉树顺序存储
- 什么是二叉树顺序存储？ 
 
按满二叉树的结点层次编号，依次存放二叉树中的数据元素，将编号为 $i$ 的结点元素存储在下标为 $i-1$ 的数组位置，这样的存储结构称为**二叉树顺序存储**。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_完全二叉树.png">
    <p>$name</p>
</div>

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_完全二叉树的顺序存储.png">
    <p>$name</p>
</div>

- 二叉树顺序存储的特点
  - 每个结点与完全二叉树的结点相对照；
  - 不存在的结点用 0 表示。
  
- 二叉树顺序存储的缺点  
  - 若深度为 $k$ 且只有 $k$个结点的二叉树，存储长度为 $2^k-1$，因此会造成存储空间的浪费。
  - 顺序存储只适合存储满二叉树或完全二叉树。

### 二叉树链式存储
- 什么是二叉树链式存储？

每个结点由**数值域**、**左子树指针域**、**右子树指针域**组成构成的链式存储称为**二叉树链式存储**。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树指针域.png">
    <p>二叉树指针域</p>
</div>

存储示例：  
<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树链式存储.png">
    <p>二叉树链式存储</p>
</div>

- 二叉树链式存储的特点
  - 根据结点的指针域可以找到每个结点的所有孩子结点，不能找到其父节点
  - 若二叉链表中存在 $n$ 个结点，则有 $n+1$ 个空指针域

## 二叉树遍历
- 什么是遍历二叉树？

顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次，称为**遍历二叉树**。

- 遍历二叉树的方法 
依次遍历二叉树中的根节点、左子树、右子树三个组成，便完成了整个二叉树的遍历。  
根据限定的先左后右的方式，可以分为：
  - 先序遍历
  - 中序遍历
  - 后序遍历

#### 先序遍历
- 二叉树先序遍历的步骤：
  - 若二叉树为空，则空操作
  - 否则，先访问根结点
  - 先序遍历左子树
  - 先序遍历右子树
  - 直至所有结点都访问一遍

- 先序遍历的示例  
对下图中的树进行先序遍历结果为：$ABDGHCEIF$

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树的先序遍历.png">
    <p>二叉树的先序遍历</p>
</div>

- 先序遍历递归算法
```
void preOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    visit(T);// 访问根结点
    preOrderTraverse(T.lchild);//递归遍历左子树
    preOrderTraverse(T.rchild);//递归遍历右子树
    }
}
```

#### 中序遍历
- 二叉树的中序遍历步骤：
  - 若二叉树为空，则空操作
  - 中序遍历左子树
  - 访问根结点
  - 中序遍历右子树
  - 直至所有结点都访问一遍
  
- 中序遍历的示例  
对下图中的树进行中序遍历结果为：$GDHBAEICF$

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树的中序遍历.png">
    <p>二叉树的中序遍历</p>
</div>

- 中序遍历递归算法
```
void inOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    inOrderTraverse(T->lchild);//递归遍历左子树
    visit(T);// 访问根结点
    inOrderTraverse(T->rchild);//递归遍历右子树
    }
}
```

- 中序遍历非递归算法  
基本思想：
  - 建立一个栈
  - 根结点进栈，遍历左子树
  - 根结点出栈，输出根结点，遍历右子树

#### 后序遍历
- 二叉树的中序遍历步骤：
  - 若二叉树为空，则空操作
  - 后序遍历左子树
  - 后序遍历右子树
  - 访问根结点
  - 直至所有结点都访问一遍

- 后序遍历的示例  
对下图中的树进行后序遍历结果为：$GHDBIEFCA$

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树的后序遍历.png">
    <p>二叉树的后序遍历</p>
</div>

- 后序遍历递归算法
```
void inOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    inOrderTraverse(T->lchild);//递归遍历左子树
    inOrderTraverse(T->rchild);//递归遍历右子树
    visit(T);// 访问根结点
    }
}
```

#### 先序/中序/后序遍历应用
- 数值表达式的前缀(波兰式)/中缀/后缀(逆波兰式)表达式  
对下图中的树进行遍历结果为：
  -  先序(波兰式)：$- * a b c$
  -  中序：$a * b - c$
  -  后序(逆波兰式)：$a b * c -$
  
<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_波兰表达式.png">
    <p>波兰表达式</p>
</div>

- 由遍历序列确定唯一二叉树

1.已知先序和中序序列求二叉树。  
先序序列：$ABCDEFGHIJ$  
中序序列：$CDBFEAIHGJ$  
**特点：先序遍历，根结点必在先序序列头部**  
唯一确定的二叉树为：  

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_先序中序.png">
    <p>先序和中序遍历产生的唯一二叉树</p>
</div>

2.已知中序和后续序列求二叉树。  
中序序列：$BDCEAFHG$  
后序序列：$DECBHGFA$  
**特点：后序遍历，根结点必在先序序列尾部**  
唯一确定的二叉树为：  

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_中序后序.png">
    <p>先序和中序遍历产生的唯一二叉树</p>
</div>

#### 先序、中序、后序遍历总结
- 先序、中序、后序遍历特点：
  - 三种遍历的递归算法中每个结点都经过三次，
  - 访问的路径是相同，只是访问结点值的时机不同。
    - 先序遍历：第1次经过时访问
    - 中序遍历：第2次经过时访问
    - 后序遍历：第3次经过时访问

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树遍历总结.png">
    <p>二叉树遍历示意图</p>
</div>

#### 层次遍历
- 什么是层次遍历？

从根结点开始，按从上到下、从左到右的顺序访问每一个结点(每个结点只访问一次)的过程称为**层次遍历**。

- 层次遍历的示例  
对下图中的树进行层次遍历结果为：$ABCDEFGHI$

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树层次遍历.png">
    <p>二叉树的层次遍历</p>
</div>

- 层次遍历实现思想
层次遍历的算法实现，需要借助一个队列：
  - 将根节点进队；
  - 队不为空时循环：从队列中出列一个结点 $p$，访问它
    - 若它有左孩子结点，将左孩子结点进队；
    - 若它有右孩子结点，将右孩子结点进队。

## 线索二叉树
- 什么是线索？  
二叉链表的存储中结点存在空指针域，则：
  - 如果结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；
  - 如果结点的右孩子为空，则将空的右孩子指针域改为指向其后继。  
这种指向前驱和后继的指针称为**线索**。

- 什么是线索二叉树？

加上了线索的二叉树称为**线索二叉树**。

- 什么是线索化？

将二叉树按某种遍历次序使其变为线索二叉树的过程称为**线索化**。

- 线索二叉树的结点结构  
为了区分左指针和右指针指向的是孩子还是前驱或后继，在二叉链表中每个结点增设两个标志域 $ltag$ 和 $rtag$：
  - $ltag=0$ ：左指针指向该结点的左孩子
  - $ltag=1$ ：左指针指向该结点的前驱
  - $rtag=0$ ：右指针指向该结点的右孩子
  - $rtag=1$ ：右指针指向该结点的后继
  
<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_线索二叉树.png">
    <p>线索二叉树的结点结构</p>
</div>

### 构造线索二叉树
- 线索二叉树构造的实质
  - 遍历二叉树得到每个结点的前驱和后继结点
  - 将二叉链表中的空指针指向前驱或后继的线索  

#### 构造线索二叉树的步骤  
- 线索二叉树
以中序遍历为例实现二叉树的线索化，增加两个指针记录结点的先后顺序：
  - 指针 $pre$ 指向刚刚访问过的结点
  - 指针 $p$ 指向当前访问的结点
  
- 以 $p$ 指向结点为根的子树中序线索化
  - 如果 $p$ 非空，左子树递归线索化。
  - 如果 $p$ 的左孩子为空，则 $p$ 的左指针指向 $pre$，将 $ltag$ 置为1；否则将 $p$ 的 $ltag$ 置为 0。
  - 如果 $pre$ 的右孩子为空，则 $pre$ 的右指针指向 $p$，将 $rtag$ 置为1；否则将 $pre$ 的 $rtag$ 置为 0。
  - 将 $pre$ 指向刚访问过的结点 $p$ ，即 $pre = p$。
  - 右子树递归线索化。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_线索二叉树中序.png">
    <p>$name</p>
</div>

- 带有头结点的线索二叉树
  - 其头结点 $ltag = 0$，左指针指向根结点；
  - $rtag = 1$，右指针指向遍历序列中最后一个结点；
  - 遍历序列中第一个结点的左指针域和最后一个结点的右指针域均指向头结点

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_线索二叉树链式存储.png">
    <p>$name</p>
</div>

### 遍历线索二叉树
> 本节讨论如何在线索二叉树中查找结点的前驱和后继结点，以下仅讨论在中序线索二叉树中查找，先序和后序线索二叉树中的查找可类似得到
#### 在中序线索二叉树中查找

- 查找结点 $p$ 的前驱结点
  - 若 $p.ltag = 1$ 表示 $p$ 的左子树空，$p.lchild$ 指向其中序前驱结点；
  - 若 $p.ltag = 0$ 表示 $p$ 的左子树不为空，则 $p$ 的中序前驱必是其左子树中第一个中序遍历到的结点。
    - 从 $p$ 的左孩子开始，沿该孩子的右指针链往下查找，直至找到一个没有右孩子的结点为止；
    - 该结点是 $p$ 的左子树中"最右下"的结点，即 $p$ 的中序前驱结点。
    
- 查找结点 $p$ 的后继结点 
  - 若 $p.rtag = 1$ 表示 $p$ 的右子树空，$p.rchild$ 指向其中序后继结点；
  - 若 $p.rtag = 0$ 表示 $p$ 的右子树不为空，则 $p$ 的中序后继必是其右子树中第一个中序遍历到的结点。
    - 从 $p$ 的右孩子开始，沿该孩子的左链往下查找，直至找到一个没有左孩子的结点为止；
    - 该结点是 $p$ 的右子树中"最左下"的结点，即 $p$ 的中序后继结点。

## 最优二叉树(赫夫曼树)
- 什么是路径和路径长度？
  - 从树中一个结点到另一个结点之间的分支构成这两个结点间的路径称为**路径**。
  - 两结点间路径上的分支数称为**结点的路径长度*。
  - 从树根到每一个结点的路径长度之和称为**树的路径长度**。

- 什么是权？
  - 将树中结点赋给一个有着某种含义的数值，则该值成为结点的**权**。
  - 从根结点到该结点之间的路径长度与该结点的权的乘积称为**结点的带权路径的长度**。
  - 树中所有叶子结点的带权路径长度之和称为**树的带权路径长度**。

- 什么是最优二叉树
带权路径长度最短的二叉树称为**最优二叉树**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_不同路径长度的二叉树.png">
    <p>不同路径长度的二叉树</p>
</div>

### 最优二叉树的构造算法
为了树的带权路径长度对小，则权越大的叶子需离根越近

- 最优二叉树的构造方法 
给定 $n$ 个权值为 ${w_1,w_2,...,w_n}$ 集合，最优二叉树的构造步骤如下：
  - 构造森林全是根：
    - 将集合中的每个元素构成一个二叉树的根节点，则所有二叉树构成森林 $F$；
    - 根结点的权为 $w_i$，并且左右子树均为空。
  - 选用两小造新树：
    - 在 $F$ 中选取两棵根节点权值最小的树作为左右子树构造成一棵新的二叉树；
    - 重置新的二叉树的根节点的权值为左右子树的根节点的权值之和。
  - 删除两小造新人：
    - 在 $F$ 中删除这两棵树；
    - 将新得到的二叉树加入到 $F$ 中。
  - 重复2、3剩单根：
    - 重复2、3步骤；
    - 直到 $F$ 只包含一棵树为止。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_赫夫曼树.png">
    <p>最优二叉树</p>
</div>

- 最优二叉树的特点
  - 包含 $n$ 棵树的森林要经过 $n-1$ 次合并才能形成最优二叉树；
  - 最优二叉树的构造过程共产生 $n-1$ 个新结点，且该 $n-1$ 个新结点都具有两个孩子的分支结点；
  - 最优二叉树共有 $2n-1$ 个结点，且所有分支结点的度均不为 1。

### 最优二叉树的构造示例
- 赫夫曼树的构造过程
  - 采用顺序存储结构，使用一维结构数组
  - 每个结点存储权重、双亲结点下标、左孩子结点下标、右孩子结点下标

- 最优二叉树的构造示例
若权 $w=(5,29,7,8,14,23,3,11)$，则构造的数组长度为 15，数组前 8 个位置放置已知结点，后 7 个位置放置新创建的结点。  
则根据权$w$构早出的赫夫曼树如下：

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_赫夫曼树例题.png">
    <p>赫夫曼树例题</p>
</div>

其构造过程的存储如下：

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_赫夫曼树构造算法.png">
    <p>赫夫曼树构造算法</p>
</div>

### 赫夫曼编码
- 赫夫曼编码特点：
  - 在使用不定长编码时，应使任意字符的编码都不是另一个字符编码的前缀。

- 赫夫曼编码步骤
  - 统计字符集中每个字符出现的平均概率（频率越大，编码越短）
  - 将每个字符的概率值作为权值构造赫夫曼树(概率越大，路径越短)
  - 在赫夫曼树的每个分支上标 0 或 1：
    - 左分支为 0，右分支为 1；
    - 把从根结点到每个叶子的路径上的标号连接起来，作为该叶子的字符编码

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_赫夫曼树编码.png">
    <p>赫夫曼树编码</p>
</div>

- 解码
  - 构造赫夫曼树
  - 依次读入二进制码，一旦到达某叶子结点时，即可译出字符
  - 再从根结点出发继续译码，直到结束


