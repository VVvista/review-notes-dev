[[toc]]
## 二叉树
**二叉树**：由$n(n\ge 0)$个结点组成的有限集，除空集外，每一个根结点最多有两棵互不相交的子树。根的左右孩子分别称为这个根的左子树和右子树

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树.png">
    <p>$name</p>
</div>

因此可以得到二叉树的特点：
* 二叉树的度不超过2
* 子树有左右之分，其次序不能颠倒
* 二叉树可以是空集，根也可以有空的左子树或空的右子树

**二叉树与树的区别**：
1. 二叉树不是树的特殊情况
2. 二叉树节点的子树要区分左子树或右子树；树结点只有一个孩子时，无需分区其左右次序。

**案例**：
1. 数据压缩-编码
2. 利用二叉树求解表达式的值

**二叉树的性质**：
1. 在二叉树的第i层上最多有$2^(i-1)$个结点,最少有1个结点
2. 深度为k的二叉树最多有$2^i-1$个结点($k\ge 1$)
3. 对任何一棵二叉树$T$,如果其叶子数为$n_0$,度为2的结点数为$n_2$，则$n_0=n_2+1$

**满二叉树**：一棵深度为$k$且有$2^k-1$个结点($k\ge 1$)的二叉树

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_满二叉树.png">
    <p>$name</p>
</div>

**满二叉树的特点**：
1. 每一层上的结点数都是最大结点数
2. 叶子结点全部在最底层

**满二叉树结点位置的编码规则**：从根结点开始，自上而下，自左而右；每一个结点位置都有元素

**完全二叉树**：深度为k的具有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$k$的满二叉树的编号$1\to n$的结点一一对应

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_完全二叉树.png">
    <p>$name</p>
</div>

**在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完成二叉树**

**完全二叉树的特点**：
1. 叶子只能分布在层次较大的两层上
2. 对任一结点，如果其右子树的最大层次为$l$，则左子树的最大层次必为$l$或$l+1$

**性质**：
1. 具有n个结点的完全二叉树的深度为$\lfloor log_{2n} \rfloor +1$
2. 如果对一棵有$n$个结点的完全二叉树的结点按层次编号，则对任一结点：
   2.1 若$i=1$，则该结点便是二叉树的根；若$i>1$,则其双亲的结点编号为$i/2$ 
   2.2 若$2i>n$,则该结点无左孩子，即该节点为叶子结点；否则其左孩子结点为$2i$
   2.3 若$2i+1>n$,则该结点无右孩子；否则其左孩子结点为$2i+1$

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_完全二叉树结点.png">
    <p>$name</p>
</div>
## 二叉树存储
### 二叉树顺序存储
**二叉树顺序存储**：按满二叉树的结点层次编号，依次存放二叉树中的数据元素，将编号为$i$的结点元素存储在下标为$i-1$的数组位置。

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_完全二叉树.png">
    <p>$name</p>
</div>

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_完全二叉树的顺序存储.png">
    <p>$name</p>
</div>

但对于一般的二叉树，应使每个结点与完全二叉树的结点相对照，不存在的结点用0表示，最坏情况：深度为k的且只有k个结点的单支树需要长度为$2^k-1$的数组，因此会造成存储空间的浪费。因此顺序存储只适合存储满二叉树或完全二叉树。

### 二叉树链式存储
每个结点由数值域、左子树指针域、右子树指针域组成构成的链式存储称为**二叉树链式存储**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树指针域.png">
    <p>$name</p>
</div>

存储示例：

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树链式存储.png">
    <p>$name</p>
</div>

在$n$个结点的二叉链表中，有$n+1$个空指针域

## 二叉树遍历
**遍历**：顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次
**二叉树的遍历方法**：依次遍历二叉树中的根节点、左子树、右子树三个组成，便完成了整个二叉树的遍历。根据限定的先左后右的方式，可以分为先序遍历、中序遍历、后续遍历

**先序遍历**：
步骤：若二叉树为空，则空操作
1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树
<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树遍历.png">
    <p>$name</p>
</div>

先序遍历结果：$ABELDHMIJ$

* 先序遍历递归算法
```
void preOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    visit(T);// 访问根结点
    preOrderTraverse(T.lchild);//递归遍历左子树
    preOrderTraverse(T.rchild);//递归遍历右子树
    }
}
```

**中序遍历**：
步骤：若二叉树为空，则空操作
1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树遍历.png">
    <p>$name</p>
</div>

中序遍历结果：$ELBAMHIDJ$

* 中序遍历递归算法
```
void inOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    inOrderTraverse(T->lchild);//递归遍历左子树
    visit(T);// 访问根结点
    inOrderTraverse(T->rchild);//递归遍历右子树
    }
}
```

* 中序遍历非递归算法

基本思想：
1. 建立一个栈
2. 根结点进栈，遍历左子树
3. 根结点出栈，输出根结点，遍历右子树

**后序遍历**：
步骤：若二叉树为空，则空操作
1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树遍历.png">
    <p>$name</p>
</div>

后序遍历结果：$LEBMIHJDA$

* 后序遍历递归算法
```
void inOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    inOrderTraverse(T->lchild);//递归遍历左子树
    inOrderTraverse(T->rchild);//递归遍历右子树
    visit(T);// 访问根结点
    }
}
```

**先/中/后序遍历应用**：
* 数值表达式的前缀(波兰式)/中缀/后缀(逆波兰式)表达式

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_波兰表达式.png">
    <p>$name</p>
</div>

遍历结果：
1. 先序(波兰式)：$-*abc$
1. 中序：$a*b-c$
1. 后序(逆波兰式)：$ab*c-$

* 由遍历序列确定二叉树

1.已知先序和中序序列求二叉树

先序序列：$ABCDEFGHIJ$

中序序列：$CDBFEAIHGJ$

**特点：先序遍历，根结点必在先序序列头部**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_先序中序.png">
    <p>$name</p>
</div>

2.已知中序和后续序列求二叉树

中序序列：$BDCEAFHG$

后序序列：$DECBHGFA$

**特点：后序遍历，根结点必在先序序列尾部**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_中序后序.png">
    <p>$name</p>
</div>

* 先/中/后序遍历递归算法总结

**三种遍历的递归算法中每个结点都经过三次，且访问的路径是相同，只是访问结点值的时机不同。**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树遍历总结.png">
    <p>$name</p>
</div>

1. 先序遍历：第1次经过时访问
2. 中序遍历：第2次经过时访问
3. 后序遍历：第3次经过时访问

**时间效率**：$O(n)$// 每个结点只访问一次

**空间效率**：$O(n)$// 栈占用的最大辅助空间

**层次遍历**：
从根结点开始，按从上到下、从左到右的顺序访问每一个结点(每个结点只访问一次)称为**层次遍历**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_二叉树层次遍历.png">
    <p>$name</p>
</div>

层次遍历结果：$abfcdgeh$

**基本思想**：使用一个队列
1. 将根节点进队
2. 队不为空时循环：从队列中出列一个结点p，访问它

   2.1 若它有左孩子结点，将左孩子结点进队
   
   2.2 若它有右孩子结点，将右孩子结点进队

## 线索二叉树
当用二叉链表作为二叉树的存储结构时，可以很方便的找到结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前驱和前驱和后继结点

### 线索二叉树的操作
**线索**：二叉链表的存储中存在空指针域，如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱，如果结点的右孩子为空，则将空的右孩子指针域改为指向其后继

加上了线索的二叉树称为**线索二叉树**；将二叉树按某种遍历次序使其变为线索二叉树的过程称为**线索化**。

**二叉树的遍历-存储结构:**

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_线索二叉树.png">
    <p>$name</p>
</div>

为了区分左指针和右指针指向的是孩子还是前驱或后继，在二叉链表中每个结点增设两个标志域ltag和rtag：
1. ltag=0 ：左指针指向该结点的左孩子
1. ltag=1 ：左指针指向该结点的前驱
1. rtag=0 ：右指针指向该结点的右孩子
1. rtag=1 ：右指针指向该结点的后继

* 先序线索二叉树
* 中序线索二叉树

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_线索二叉树中序.png">
    <p>$name</p>
</div>

* 后序线索二叉树

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_线索二叉树后序.png">
    <p>$name</p>
</div>

带有头结点的线索二叉树：其头结点ltag=0，左指针指向根结点，rtag=1，右指针指向遍历序列中最后一个结点，并且遍历序列中第一个结点的左指针域和最后一个结点的右指针域均指向头结点

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_线索二叉树链式存储.png">
    <p>$name</p>
</div>


## 最优二叉树(赫夫曼树)
### 基础概念
**路径**：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径

**结点的路径长度**：两结点间路径上的分支数

**树的路径长度**：从树根到每一个结点的路径长度之和

**权**：将树中结点赋给一个有着某种含义的数值，则该值成为结点的权

**结点的带权路径的长度**：从根结点到该结点之间的路径长度与该结点的权的乘积

**树的带权路径长度**：树中所有叶子结点的带权路径长度之和

**最优二叉树**：带权路径长度最短的二叉树

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_不同路径长度的二叉树.png">
    <p>$name</p>
</div>

### 构造算法
为了树的带权路径长度对小，则权越大的叶子需离根越近

**构造方法**：
1. 根据给定的$n$个权值${w_1,w_2,...,w_n}$构成$n$棵二叉树的集合$F={T_1,T_2,...,T_N}$，其中每棵二叉树$T_i$只有一个带权为$w_i$的根结点，其左右子树均为空。
1. 在$F$中选取两棵根节点权值最小的树作为左右子树构造成一棵新的二叉树，且重置新的二叉树的根节点的权值为左右子树的根节点的权值之和。
1. 在$F$中删除这两棵树，同时将新得到的二叉树加入到$F$中。
1. 重复2、3步骤，直到$F$只包含一棵树为止。
以上步骤可归纳为：构造森林全是根，选用两小造新树，删除两小造新人，重复2、3剩单根

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_赫夫曼树.png">
    <p>$name</p>
</div>

**总结**：
1. 包含n棵树的森林要经过$n-1$次合并才能形成赫夫曼树，共产生$n-1$个新结点，且该$n-1$个新结点都具有两个孩子的分支结点
1. 赫夫曼树共有$2n-1$个结点，且所有分支结点的度均不为1

### 构造算法实现
赫夫曼树的构造过程，采用顺序存储结构，使用一维结构数组；每个结点存储权重、双亲结点下标、左孩子结点下标、右孩子结点下标

例：若权$w=(5,29,7,8,14,23,3,11)$,则构造的数组长度为15，数组前8个位置放置已知结点，后7个位置放置新创建的结点。而其存储过程就是将赫夫曼树在构建过程中的结点值进行更改的过程
则根据权$w$构早出的赫夫曼树如下：

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_赫夫曼树例题.png">
    <p>$name</p>
</div>

其构造过程的存储如下：

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_赫夫曼树构造算法.png">
    <p>$name</p>
</div>

### 赫夫曼编码
在使用不定长编码时，应使任意字符的编码都不是另一个字符编码的前缀。

**赫夫曼编码步骤**：
1. 统计字符集中每个字符出现的平均概率（频率越大，编码越短）
1. 将每个字符的概率值作为权值构造赫夫曼树(概率越大，路径越短)
1. 在赫夫曼树的每个分支上标0或1： 左分支为0，右分支为1；把从根结点到每个叶子的路径上的标号连接起来，作为该叶子的字符编码

<div align="center">
    <img src="https://blog-review-notes.oss-cn-beijing.aliyuncs.com/algorithm/data-structures/_images/树_赫夫曼树编码.png">
    <p>$name</p>
</div>

**解码**：
1. 构造赫夫曼树
1. 依次读入二进制码，一旦到达某叶子结点时，即可译出字符
1. 再从根结点出发继续译码，直到结束


