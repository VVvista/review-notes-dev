[[toc]]
## 队列
只能在表的一端进行插入，另一端进行进行删除，且操作具有**先进先出**原则的线性表称为队列。
  - 进行删除的一端称为队头。  
  - 进行插入的一端称为队尾。  
  - 先进先出原则：先入队的元素在队头，后入队的元素在队尾。
  
<div align="center">
    <img src="https://vista-image.oss-cn-beijing.aliyuncs.com/datastructure/image/队列_示意图.png" width="40%">
</div>

若用 $S=(a_1,a_2,a_3,...,a_n)$ 表示队列，则：  
 &emsp;-&ensp;$a_1$ 称为队头元素；  
 &emsp;-&ensp;$a_n$ 称为队尾元素；  
 &emsp;-&ensp;没有元素的队列称为空队列。   
 
队列常见的两种操作： 
  - 入队：插入数据到队尾。
  - 出队：删除队头第一个元素。
  
限定插入和删除操作在表的两端进行的线性表称为双端队列。

<div align="center">
    <img src="https://vista-image.oss-cn-beijing.aliyuncs.com/datastructure/image/队列_双端队列.png">
</div>

双端队列又可以分为：
  - 输出受限的双端队列：一个端点只允许插入和删除，另一个端点只允许插入。
  - 输入受限的双端队列：一个端点只允许插入和删除，另一个端点只允许删除。
  - 双端队列也可以退化成栈，即只能在一端进行插入和删除。

#### 队列基本操作
- 向队尾添加元素(入队)
- 删除队首元素(出队)
- 获取队首的元素值(存取)
- 判断队列是否为满
- 判断队列是否为空

## 顺序队列
用顺序存储方式存储的队列称为顺序队列。

元素入队只需将元素添加到队列的最后一个位置即可，但元素出队时队头元素的位置如何变化？
  - 元素出队后，只需将下一个元素设置成新队头。  
  优点：队列中其他元素地址无需改变；  
  缺点：随着元素不断出队，队头位置后移，可能出现存储空间不足的情况，从而导致新元素无法入队；同时队头前端存在大量空闲存储空间，造成空间的浪费。
  - 队头元素必须存放在存储空间的第一个位置，元素出队后，所有元素向前移动一个位置。  
  优点：有效的利用了存储空间；
  缺点：所有元素存储位置都要改变，时间效率低。
      
出于空间、时间效率考虑，暂时采用牺牲空间换取时间的方式，采用方式 1 来设置队头 。

队列指针的设置及队空判断：  
  - 设 $front$ 为队头指针，指示队头元素在顺序队列中的位置
  - 设 $rear$ 为队尾指针，指示队尾元素的下一个位置，初始化时指向队头：$front == rear$
  - 用 $maxSize$ 表示队列的存储空间大小
  - 当 $front == rear$ 时队空，当 $front == maxSize$ 时队列溢出，不能再添加元素    

#### 顺序队列的初始化
- 为顺序队列分配初始存储空间 $maxSize$，使 $front$ 指向空间的基地址。
- 设 $front == rear$。

#### 顺序队列的入队
- 判断队列是否溢出，若溢出不能再添加元素
- 否则将新元素入队，队尾指针加 1：$rear = rear + 1$ 

#### 顺序队列之出队
- 判断队列是否为空，若队空则不能删除元素
- 否则队头元素出队，队头指针加 1：$front = front + 1$

## 循环队列
将队头与队尾连接形成闭环的队列称为循环队列。
  - 元素出队，队头指针顺时针移动一个位置；
  - 元素入队，队尾指针顺时针移动一个位置。
  
<div align="center">
    <img src="https://vista-image.oss-cn-beijing.aliyuncs.com/datastructure/image/队列_循环队列.png"  width="30%">
</div>

与顺序队列的溢出不同，循环队列队满时便不能再添加新的元素。  
若 $front$ 和 $rear$ 指针的定义与顺序队列中相同，则出现 $front == rear$ 时无法判断队列是满还是空的情况，所以如何判断队满不呢？
  - 新增变量 $count$ 标识队列元素个数，当 $count == maxSize$ 时为队满；当 $count = 0$ 时队空。
  - 循环队列少用一个元素，当队头指针在队尾指针的下一个位置时，队列为满，队列元素为 $maxSize - 1$；当 $front == rear$ 时队空。   
为了操作的便捷性，通常采用方式 2 判断队空队满，以下循环队列的操作以方式 2 为基准。

队空队满及队列元素个数判断：
  - 当 $( rear + 1 )  \%  maxSize == front$ 时队满；
  - 当 $front ==  rear$ 时队空；
  - 队列中有效元素个数：$(rear + maxSize - front) \% maxSize$。

#### 循环队列的初始化
- 为循环队列分配初始存储空间 $maxSize$，使 $front$ 指向空间的基地址。
- 设 $front == rear$。

#### 循环队列有效长度
- 循环队列的有效长度：$(rear + maxSize - front) \% maxSize$

#### 循环队列的入队
- 判断循环队列是否为满：$( rear + 1 ) \% maxSize == front$ ，若队满则不能添加新元素
- 否则将新元素入队，队尾指针加 1：$rear = (rear + 1) \% maxSize$ 

#### 循环队列之出队
- 判断队列是否为空：$front == rear$，若队空则不能再删除元素
- 否则队头元素出队，队头指针加 1：$front = (front + 1) \% maxSize$


## 链式队列
- 什么是链式队列？

用链接存储方式实现的队列称为链式队列。  

<div align="center">
    <img src="https://vista-image.oss-cn-beijing.aliyuncs.com/datastructure/image/队列_链式队列.png">
    <p>链式队列</p>
</div>

- 链式队列的指针
链式队列添加头结点，使头指针指向头结点，同时增设两个指针：
  - 设队头指针 $front$ ，始终指向头结点
  - 设队尾指针 $rear$ ，指向队尾结点，初始化时 $front == rear$指向头结点

#### 链式队列的初始化
操作步骤如下：
- 创建一个新结点作为链式队列的头结点，并将队头和队尾指针指向头结点
- 头结点的指针域为 $null$

#### 链式队列的入队
链式队列的入队就是将数据元素插入到队尾，具体操作如下：
- 创建指针域为 $null$ 的新结点 $p$ 
- 将新结点插入到队尾结点之后，修改队尾结点指针域：$rear.next = p$
- 修改队尾指针：$rear = p$

#### 链式队列之出队
链式队列的出队就是删除链表的首元结点，具体操作如下：
- 判断队列是否为空，若为空则不能删除结点
- 否则获取首元结点 $p$ 的数据域
- 进行删除首元结点操作，修改队头指针指向下一个结点：$front.next = p.next$
- 元素出队后再次判断队列是否为空，若为空将队尾指针指向头结点：$rear = front$
- 释放结点 $p$

<div align="center">
    <img src="https://vista-image.oss-cn-beijing.aliyuncs.com/datastructure/image/队列_链式的操作.png">
    <p>链式的操作</p>
</div>

#### 循环队列和链式队列的比较
- 时间复杂度
  - 循环队列和链式队列入队和出队的时间复杂度都为 $O(1)$
  
- 空间上复杂度
  - 循环队列初始化时必须申请存储空间，队列的有效长度受限，在操作过程中队列的有效元素个数小于存储空间大小，所以造成空间浪费。
  - 链式队列存储过程中需要一个指针域，会产生空间上的开销，但队列元素个数不会受限制。

#### 顺序队列与链式队列的比较
- 顺序队列有固定的存储空间，不适用于存储空间很大，删除插入很频繁的操作，此时顺序队列的空间利用率很低；反之，链式队列适用此情况。
- 顺序队列的访问简单，对队列内部元素的访问便捷；链式队列元素需便利整个链表。

#### 应用实例
- 银行拿号排队问题


 参考资料：  
[1] 《数据结构(C语言版)》 严魏敏、吴伟民著  
[2] 《数据结构(第3版)》 刘大有等著  