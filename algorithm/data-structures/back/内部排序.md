[[toc]]
## 基本概念和排序方法概述
**内部排序**：将需要处理的所有数据加载到内存中进行的排序

**外部排序**：数据量过大，无法全部加载到内存中，需借助外部存储进行的排序

**稳定**：具有相同关键字的数据元素的相对位置关系在排序前后保持不变

**不稳定**：具有相同关键字的数据元素的性对位置关系在排序前后发生变化

## 插入排序
### 直接插入排序
**基本思想**：将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表

![tt](_images/排序_插入排序.gif "tt")

**具体操作步骤如下**：

**基本操作**：比较两个关键字的大小和移动记录

**时间复杂度**：$O(n^2)$

**总结**：当代排序记录的数量$n$很小时，适合使用插入排序。但待排序序列中的记录数量$n$很大时，不推荐使用直接插入排序

**优化**：减少'比较'和'移动'两种操作的次数

### 希尔排序（最小增量排序）
**定义**：先将整个待排记录序列分隔成为若干子序列分别惊醒直接插入排序，带整个序列中的记录'基本有序'时，在对全体记录进行一次直接插入排序

![tt](_images/排序_希尔排序.webp "tt")

**具体操作步骤如下**：

**特点**：子序列的构成不是简单的'逐段分隔'，而是将相隔某个'增量'的记录组成一个子序列。

## 交换排序
### 冒泡排序
冒泡排序采用交换的思想，不断的交换序列中的反序对，直到不再有反序对位置

**定义**：

![tt](_images/排序_冒泡排序.gif "tt")

**具体操作步骤如下**：
1. 首先将第一个记录的关键字与第二个记录的关键字进行比较，若为逆序，则将两个记录交换，然后比较第二个记录和第三个记录的关键字。以此类推，直到第$n-1$个记录和第$n$个记录的关键字进行过比较为止。该过程成为第一趟冒泡排序，其结果时的关键字的最大纪录被安置到最后一个记录的位置上。
2. 然后进行第二趟冒泡排序，对前$n-1$个记录进行同样操作，将关键字次大的记录被安置在第$n-1个$记录的位置上
k. 直到第$k(1\ge k<n)$趟排序过程中灭有进行过交换记录的操作。

**总结**：若初始序列为'正序'序列，则只需进行一趟排序，在排序过程中进行$n-1$此关键字间的比较，且不易懂记录;

反之，若初始序列为'逆序'序列，则只需要进行$n-1$趟排序，需进行$\frac {n(n-1)}{2}$次比较，并做等数量级的记录移动。

**时间复杂度**：$O(n^2)$

### 快速排序
**基本思想**：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对两部分记录继续进行排序，已达到整个序列的有序

**具体实现**：选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边

**中间数**：可以是第一个数、最后一个数、最中间一个数，任意一个数

![tt](_images/排序_快速排序.gif "tt")

**具体操作步骤如下**：

**总结**：在同数量及的排序方法中，快速排序的平均性能最好

**时间复杂度**：$O(nlog{2n})$，最坏情况（待排序列接近有序）时间复杂度为O(n2)

**稳定性**：不稳定

特殊示例$(2，14，26，31，65)$ 或$(67，45，32，21，2)$

当序列原本为有序列时，一次划分之后得到的子序列一端为0，此时已经退化为没有改进措施的冒泡排序.快速排序不适合对'原本有序'或'基本有序'的记录序列进行排序

**划分元素的选取时影响时间性能的关键**：
* 当输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序不是自然排序方法。
* 当输入数据有序时，改变划分元素的选取方法，之多只能改变算法平均情况下的时间性能，无法改变最坏情况下的时间性能，最坏情况下，时间复杂度为$O(n^2)$

## 选择排序
**基本思想**：每一趟在$n-i+1$个记录中选取关键字最小的记录作为有序序列中第$i$个记录

### 简单选择排序
**基本思想**：通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i(1\ge i \ge n)$个记录交换

**具体操作步骤如下**：
1. 通过$n-1$次关键字比较，从$n$个记录中找出关键字最小的记录，将它与第一个记录交换
2. 通过$n-2$次比较，从剩余的$n-1$个记录中找出关键字次小的记录，将它与第二个记录交换
3. ...
4. 重复上述操作，共进行$n-1$趟排序后，排序结束

![tt](_images/排序_选择排序.webp "tt")

**时间复杂度**：$O(n^2)$

**稳定性**：不稳定

### 堆排序
### 初级实现
### 堆的定义
### 堆的算法
### 堆排序
若在输出堆顶的最小值之后，使得剩余$n-1$个元素的序列重新又建成一个堆，则得到$n$个元素中的次小值。如此反复执行，便能得到一个有序序列

【插图】

**具体操作步骤如下**：

## 归并排序
**归并**：将两个或两个以上的有序表组合成一个新的有序表

若初始序列有$n$个记录，则可看成$n$个有序的子序列，每个子序列的长度为1，然后两两归并，得到$n/2$个长度为2或1的有序子序列；在两两归并...如此重复，直到最后得到一个长度为n的有序序列为止。

![tt](_images/排序_归并排序.gif "tt")
**具体操作步骤如下**：

### 原地归并的抽象方法
### 自顶向下的归并排序
### 自顶向上的归并排序

## 基数排序
【插图】
**具体操作步骤如下**：

### 多关键字的排序
【插图】
**具体操作步骤如下**：

### 链式基数排序
【插图】
**具体操作步骤如下**：

## 分布排序
【插图】
**具体操作步骤如下**：

