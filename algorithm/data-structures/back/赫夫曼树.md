
## 赫夫曼树
### 基础概念
**路径**：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径

**结点的路径长度**：两结点间路径上的分支数

**树的路径长度**：从树根到每一个结点的路径长度之和

**权**：将树中结点赋给一个有着某种含义的数值，则该值成为结点的权

**结点的带权路径的长度**：从根结点到该结点之间的路径长度与该结点的权的乘积

**树的带权路径长度**：树中所有叶子结点的带权路径长度之和

**最优二叉树**：带权路径长度最短的二叉树

### 赫夫曼树构造算法
#### 构造算法
**赫夫曼树中权越大的叶子离根越近**

**构造方法**：
1. 构造森林全是根
1. 选用两小造新树
1. 删除两小造新人
1. 重复2、3剩单根

![tt](_images/树_赫夫曼树.png "tt")

**总结**：
1. 包含n棵树的森林要经过$n-1$次合并才能形成赫夫曼树，共产生$n-1$个新结点，且该$n-1$个新结点都具有两个孩子的分支结点
1. 赫夫曼树共有$2n-1$个结点，且所有分支结点的度均不为1

#### 构造算法实现
**采用顺序存储结构，使用一维结构数组**

**权重**：双亲结点下标：左孩子结点下标：右孩子结点下标

![tt](_images/树_赫夫曼树构造算法.png "tt")

#### 赫夫曼编码
**要求**：使用不定长编码，且任意字符的编码都不是另一个字符编码的前缀

**赫夫曼编码**：
1. 统计字符集中每个字符出现的平均概率（频率越大，编码越短）
1. 将每个字符的概率值作为权值构造赫夫曼树(概率越大，路径越短)
1. 在赫夫曼树的每个分支上标0或1： 左分支为0，右分支为1；把从根结点到每个叶子的路径上的标号连接起来，作为该叶子的字符编码

![tt](_images/树_赫夫曼树编码.png "tt")

**解码**：
1. 构造赫夫曼树
1. 依次读入二进制码，一旦到达某叶子结点时，即可译出字符
1. 再从根结点出发继续译码，直到结束

