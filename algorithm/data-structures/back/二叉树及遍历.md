[[toc]]
## 二叉树
**二叉树**：由$n(n\ge 0)$个结点组成的有限集，除空集外，每一个根结点及两棵互不相交的分别称为这个根的左子树和右子树

![tt](_images/树_二叉树.png "tt")

**特点**：
* 二叉树的度不超过2
* 子树有左右之分，其次序不能颠倒
* 二叉树可以是空集，根也可以有空的左子树或空的右子树

**二叉树与树的区别**：
1. 二叉树不是树的特殊情况
2. 二叉树节点的子树要区分左子树或右子树；树结点只有一个孩子时，无需分区其左右次序。

**案例**：
1. 数据压缩-编码
2. 利用二叉树求解表达式的值

**二叉树的性质**：
1. 在二叉树的第i层上最多有$2^(i-1)$个结点,最少有1个结点
2. 深度为k的二叉树最多有$2^i-1$个结点($k\ge 1$)
3. 对任何一颗二叉树$T$,如果其叶子数为$n_0$,度为2的结点数为$n_2$，则$n_0=n_2+1$

**满二叉树**：一棵树深度为$k$且有$2^k-1$个结点($k\ge 1$)的二叉树

![tt](_images/树_满二叉树.png "tt")

**特点**：
1. 每一层上的结点数都是最大结点数
2. 叶子结点全部在最底层

**满二叉树结点位置的编码规则**：从根结点开始，自上而下，自左而右；每一个结点位置都有元素

**完全二叉树**：($k\ge 1$)

![tt](_images/树_完全二叉树.png "tt")

**完全二叉树**：深度为k的具有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$k$的满二叉树的编号$1\to n$的结点一一对应

**在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完成二叉树**

**特点**：
1. 叶子只能分布在层次较大的两层上
2. 对任一结点，如果其右子树的最大层次为$i$，则左子树的最大层次必为$i$或$i+1$

**性质**：
1. 具有n个结点的完全二叉树的深度为$\lfloor log_{2n} \rfloor +1$

### 二叉树顺序存储
**二叉树顺序存储**：按满二叉树的结点层次编号，依次存放二叉树中的数据元素

![tt](_images/树_完全二叉树.png "tt")

**存储格式**：
$$
\begin{pmatrix}
1&2$3$4$5$6$7$8$9$10$11$12\\
\end{pmatrix}
$$

**缺点**：
1. 只适合存储满二叉树或完全二叉树，最坏情况：深度为k的且只有k个结点的单支树需要长度为$2^k-1$的数组

### 二叉树链式存储
**二叉树链式存储**：每个结点由数值域，左子树指针、右子树指针组成

![tt](_images/树_二叉树指针域.png "tt")

![tt](_images/树_二叉树链式存储.png "tt")

在$n$个结点的二叉链表中，有$n+1$个空指针域

### 二叉树遍历
**遍历**：顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次
**方法**：依次遍历二叉树中的三个组成部分，便是遍历了整个二叉树

#### 先序遍历
**步骤**：若二叉树为空，则空操作
1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树
![tt](_images/树_二叉树遍历.png "tt")

先序遍历结果：$ABELDHMIJ$

* 先序遍历递归算法
```
void preOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    visit(T);// 访问根结点
    preOrderTraverse(T->lchild);//递归遍历左子树
    preOrderTraverse(T->rchild);//递归遍历右子树
    }
}
```
* 先序遍历非递归算法

#### 中序遍历
**步骤**：若二叉树为空，则空操作
1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

![tt](_images/树_二叉树遍历.png "tt")

中序遍历结果：$ELBAMHIDJ$

* 中序遍历递归算法
```
void inOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    inOrderTraverse(T->lchild);//递归遍历左子树
    visit(T);// 访问根结点
    inOrderTraverse(T->rchild);//递归遍历右子树
    }
}
```

* 中序遍历非递归算法

基本思想：
1. 建立一个栈
2. 根结点进栈，遍历左子树
3. 根结点出栈，输出根结点，遍历右子树
```
void inOrderTraverse(BiTree T){
  【算法实现】
}
```

#### 后序遍历
**步骤**：若二叉树为空，则空操作
1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

![tt](_images/树_二叉树遍历.png "tt")

后序遍历结果：$LEBMIHJDA$

* 后序遍历递归算法
```
void inOrderTraverse(BiTree T){
if(T==null) return ;// 空二叉树
else {
    inOrderTraverse(T->lchild);//递归遍历左子树
    inOrderTraverse(T->rchild);//递归遍历右子树
    visit(T);// 访问根结点
    }
}
```
* 后序遍历非递归算法

#### 先/中/后序遍历应用
* 数值表达式的前缀(波兰式)/中缀/后缀(逆波兰式)表达式

![tt](_images/树_波兰表达式.png "tt")

遍历结果：
1. 先序(波兰式)：$-*abc$
1. 中序：$a*b-c$
1. 后序(逆波兰式)：$ab*c-$

* 由遍历序列确定二叉树

1.已知先序和中序序列求二叉树

先序序列：$ABCDEFGHIJ$

中序序列：$CDBFEAIHGJ$

**特点：先序遍历，根结点必在先序序列头部**

![tt](_images/树_先序中序.png "tt")

2.已知中序和后续序列求二叉树

中序序列：$BDCEAFHG$

后序序列：$DECBHGFA$

**特点：后序遍历，根结点必在先序序列尾部**

![tt](_images/树_中序后序.png "tt")

* 先/中/后序遍历递归算法总结

**三种遍历的递归算法中每个结点都经过三次，且访问的路径是相同，只是访问结点值的时机不同。**

![tt](_images/树_二叉树遍历总结.png "tt")

1. 先序遍历：第1次经过时访问
2. 中序遍历：第2次经过时访问
3. 后序遍历：第3次经过时访问

**时间效率**：$O(n)$// 每个结点只访问一次

**空间效率**：$O(n)$// 栈占用的最大辅助空间

#### 层次遍历
**层次遍历**:从根结点开始，按从上到下、从左到右的顺序访问每一个结点(每个算法只访问一次)

![tt](_images/树_二叉树层次遍历.png "tt")

层次遍历结果：$abfcdgeh$

**基本思想**：使用一个队列
1. 将根节点进队
2. 队不为空时循环：从队列中出列一个结点p，访问它

   2.1 若它有左孩子结点，将左孩子结点进队
   
   2.2 若它有右孩子结点，将右孩子结点进队

```
void levelOrder(BTNode T){
  【算法实现】
}
```